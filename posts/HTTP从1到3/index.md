---
title: HTTP从1到3
abbrlink: 2414947904
date: 2021-06-12 23:26:09
tags: 
    - 计算机基础
---

# HTTP从1到3

最近想回顾一下HTTP方面的知识，今天就从HTTP协议的版本讲起。说起HTTP的版本变迁，首先就会想到为什么HTTP会从1进化到3？答案很简单因为随着互联网的发展旧版的HTTP出现了令人无法忍受的缺陷所以我们要推出新的HTTP来修复旧版本的缺陷使得HTTP能够更好的适应互联网的发展。本文就以旧版HTTP有哪些缺陷以及新版HTTP是如何解决的为线索来讲述为什么HTTP会从1到3。

## HTTP从1.0到1.1

### HTTP 1.0的缺点

我们知道HTTP是建立在TCP之上的应用层协议，也就是说我们要先建立TCP连接才能进行HTTP通信。在HTTP 1.0的版本中客户端每发起一次HTTP请求都要先建立一个TCP连接，然后才是发送HTTP请求，最后当客户端收到服务器发送的响应后就会关闭TCP连接。简而言之每发起一次HTTP请求都会建立一次TCP连接，如果需要N次HTTP请求就会建立起N次TCP连接。如下图所示

![HTTP 1.0请求过程](https://picture-glimmertreasure-com.oss-cn-hangzhou.aliyuncs.com/HTTP/1.0%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B.svg)

<center style="font-size:14px;color:#C0C0C0;text-decoration:underline">HTTP 1.0的请求过程</center> 



在早期这种做法无可厚非，但是随着web页面HTTP请求的增多，每次请求都要建立TCP连接不仅浪费TCP资源而且还增加了用户的等待时间，毕竟TCP的三次握手还是很耗时间的。

### HTTP 1.1的改进

针对这一缺点，HTTP1.1版本被推了出来，HTTP 1.1版本增加了长链接功能（Connection: Keep-Alive）。这样当客户端对一个域名发起HTTP请求并收到响应后并不会立刻关闭TCP连接，而是将TCP连接保留一段时间。这样当客户端如果再对该域名下的其他资源发起请求时如果TCP连接还没被关闭就会复用该TCP连接从而避免了TCP连接的创建过程减少客户端的等待时间。如下图所示

![HTTP 1.0发送多个请求](https://picture-glimmertreasure-com.oss-cn-hangzhou.aliyuncs.com/HTTP%201.0%E5%8F%91%E9%80%81%E5%A4%9A%E4%B8%AA%E8%AF%B7%E6%B1%82.svg)

<center style="font-size:14px;color:#C0C0C0;text-decoration:underline">HTTP 1.0发送多个请求</center> 

![HTTP 1.1长链接下发送多个请求](https://picture-glimmertreasure-com.oss-cn-hangzhou.aliyuncs.com/HTTP%201.1%E9%95%BF%E9%93%BE%E6%8E%A5%E4%B8%8B%E5%8F%91%E9%80%81%E5%A4%9A%E4%B8%AA%E8%AF%B7%E6%B1%82.svg)

<center style="font-size:14px;color:#C0C0C0;text-decoration:underline">HTTP 1.1长链接下发送多个请求</center> 

从上图我们可以看到相比于HTTP 1.0，HTTP 1.1默认开启的长链接模式能够复用之前创建好的TCP连接，避免在请求过程中多次创建和断开TCP连接，降低了用户的等待时间。

需要注意的是在长链接模式下浏览器创建TCP连接的策略是对不同域名的请求浏览器会使用不同TCP连接，对同一域名下的请求浏览器会使用同一个TCP连接。对于同一个域名下的请求浏览器会对请求进行排队依次通过TCP连接进行发送，只有当上一个请求收到响应后才会让取出队列中的下一个请求进行发送。

虽然在HTTP 1.1中通过同一域名下的请求复用TCP连接的方式提高了TCP连接的利用率降低了用户的等待时间，但是只有当上个请求收到响应后才发送下一个请求的串行发送方式并不完美。如果当前发送的请求因为各种原因迟迟没有收到响应那么在队列中的其他请求也必须进行等待，从而造成请求阻塞。

为了解决HTTP 1.1在复用TCP连接时由于串行发送的请求中某一请求迟迟无法响应从而造成整个请求队列被阻塞的问题，浏览器允许同一域名下最多创建6个TCP连接。这样同一域名下的所用HTTP请求被分配到了6个不同的队列中去，即使有一个队列在传输过程中被阻塞掉了，但是由于还有其他的队列在正常发送不至于该域名下的所有请求都无法得到响应，从而将损失降到最小。

## HTTP从1.1到2

### HTTP 1.1的缺点

通过上面的讲述，我们知道HTTP 1.1通过长链接的方式提高了TCP连接的利用率，但是为了避免因为当前请求迟迟无法响应导致后续请求无法发出的情况，不得不做出妥协，即允许相同域名下的请求最多可以同时建立起6个TCP连接，这种妥协大大降低了TCP的利用率。为了将TCP连接的利用率达到最大化即同一域名下的请求全部通过一个TCP连接发送，于是便提出了HTTP 2。

### HTTP 2的改进

通过上面的介绍我们知道之所以会产生在同一TCP连接中请求队列阻塞的问题是因为在HTTP 1.1版本中在同一个TCP连接中传输的请求是串行发送的，如果我们能在一个TCP连接中并行的发送所有请求，那么即使其中一条请求出现延迟也不会影响到其他的请求。HTTP 2 就是通过在一条TCP连接上并发（逻辑上的并行）发送所用HTTP请求来解决这个问题，下面我们来讲一下HTTP  2是如何实现并发发送HTTP请求的。

为了实现并发发送HTTP请求，HTTP 2对请求发送方式做了一些修改。

1. **二进制传输：**所有的HTTP请求不再是一明文的方式传输而是以二级制的方式进行传输。
2. **二进制帧：**二进制帧就是将一整块二进制数据进行切片。在之前的HTTP中最小的传输单元便是一个HTTP请求报文，而在HTTP 2中最小的传输单元是一个二进制帧。这是一种更细粒度上划分，一个HTTP请求报文可以被切片成多个帧从而在TCP连接上一帧一帧的发送。
3. **流：**一次完整的HTTP请求（请求+响应）便是一个流，因此流是双向。也就说是一个完整的HTTP请求（请求+响应）的所有二进制帧组成了一个流，每一个流都用一个整数ID来标识。

当我们发起HTTP请求时，同一域名下的所有请求首先是被编码成二级制数据。然后将这些二进制数据切片成一个个二进制帧，属于同一请求的每个二进制帧会携带相同的流ID。然后客户端将一个个二进制帧通过TCP连接发送到服务器上。当服务器收到二进制帧后，会根据帧上的流ID区分接收到的帧属于哪个请求，当请求的所有帧都接收完毕后会被服务器重新组装成完整的HTTP请求。接下来服务器会把请求对应的响应也切成二进制帧并带上流ID通过TCP发送给客户端。客户端收到二进制帧后通过帧上携带的流ID便可知的该帧属于哪个请求对应的响应，当所用帧都被接收后客户端便把帧组装成完整的响应。



![HTTP 2请求流程图](https://picture-glimmertreasure-com.oss-cn-hangzhou.aliyuncs.com/HTTP%202%E8%AF%B7%E6%B1%82%E6%B5%81%E7%A8%8B%E5%9B%BE.svg)

<center style="font-size:14px;color:#C0C0C0;text-decoration:underline">HTTP 2请求流程图</center> 

通过上图我们可以看到虽然在TCP连接中二进制帧是串行发送的，但是我们在宏观上看请求就是像是在并行发送一样，这样以来即使某一个请求无法收到响应也不会影响到客户端的其他请求正常发送和接收响应。

## HTTP从2到3

### HTTP 2的缺点

HTTP 2通过引入二进制帧的方法实现了相同域名下的所用请求在同一个TCP连接上并发发送和接收从而实现了TCP利用率的最大化。但是我们知道TCP是面向连接可靠传输的协议，这意味着每次发送的报文都需接收者在接收之后向发送者发送确认消息，发送者收到确认消息后才会发送下一个报文，否则就会一直等待，直到收到确认消息或者等待超时后重新发送报文。这样看来一旦客户端发现发送的TCP报文由于某种原因没有收到确认消息，整个连接就会进入等待状态，那么之后的所有二进制帧都不能再被发送了，这样就相当于所有的请求都被阻塞住了。

### HTTP 3的改进

造成HTTP 2的队头阻塞的根本原因是TCP的重传机制，通过修改TCP来修复这个问题显然是不切实际的。因此HTTP 3底层不再采用TCP来传输数据而是使用无连接和不可靠传输的UDP来发送数据。因为是无连接的协议所以在发送时不必经过握手过程所以省去了HTTP2中TCP的握手时间。由于是不可靠传输所以即使出现报文丢失的情况也不会阻塞其他报文的发送，当然因为UDP是不可靠的传输协议因此如何发现报文丢失以及如何进行重传的机制需要HTTP 3内部自己实现。

## 总结

整篇文章以如何提高TCP连接的利用率以及如何解决队头阻塞为线索依次讲述HTTP 从1到3的协议变迁过程，但是并不代表每个版本只有对上个版本这方面的改进，其他方面的改进我会在以后的学习过程中慢慢添加进来。
