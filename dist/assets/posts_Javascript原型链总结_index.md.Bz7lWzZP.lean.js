import{_ as o,c as i,a5 as e,G as s,B as p,o as c}from"./chunks/framework.COT_U_ro.js";const u=JSON.parse('{"title":"JavaScript原型链总结","description":"","frontmatter":{"title":"JavaScript原型链总结","date":"2024-09-12T19:10:32.000Z","categories":null,"tags":["JavaScript","前端"]},"headers":[],"relativePath":"posts/Javascript原型链总结/index.md","filePath":"posts/Javascript原型链总结/index.md"}'),n={name:"posts/Javascript原型链总结/index.md"};function d(r,a,l,h,k,g){const t=p("BlogImage");return c(),i("div",null,[a[0]||(a[0]=e(`<h1 id="javascript原型链总结" tabindex="-1">JavaScript原型链总结 <a class="header-anchor" href="#javascript原型链总结" aria-label="Permalink to &quot;JavaScript原型链总结&quot;">​</a></h1><p>在JavaScript中有两个重要且基础的链，一个是作用域链一个是原型链。今天对原型链做一个总结。</p><h2 id="什么是原型链" tabindex="-1">什么是原型链 <a class="header-anchor" href="#什么是原型链" aria-label="Permalink to &quot;什么是原型链&quot;">​</a></h2><p>什么是原型链？我们知道继承是对象语言的特性之一，任何包含对象的语言都有继承这一特性。在Java与C++中是基于类实现的继承，因此在Java与C++中访问一个对象的属性，如果该对象上没有这个属性，那么就会去父类上找该属性，如果还是没有，就会去父类的父类上找，以此类推直到找到为止；或者直到基类仍没有找到该属性，那么就返回null。JavaScript则不同，它没有采用基于类的继承实现方式，而是采用了原型链的实现方式。在JavaScript中访问一个对象的属性，如果该对象没有此属性，那么就会去该对象的原型对象上去找此属性，如果原型对象上也没有此属性，那么就去原型对象的原型对象上找此属性，以此类推，直到找到此属性为止；或者一直没有找到则返回null。 由以上可知，原型链就是JavaScript语言中实现继承的方式，也是JavaScript语言中对象属性的访问机制。</p><h2 id="与原型相关的属性-proto-与-prototype" tabindex="-1">与原型相关的属性（__proto__与[[Prototype]]） <a class="header-anchor" href="#与原型相关的属性-proto-与-prototype" aria-label="Permalink to &quot;与原型相关的属性（\\_\\_proto\\_\\_与[[Prototype]]）&quot;">​</a></h2><p>熟悉JavaScript的同学都知道，JavaScript对象的<code>__proto__</code>属性指向该对象的原型，但这是一个非标准属性。在ECMAScript 标准中对象<code>[[Prototype]]</code>的属性用于指定对象的原型，并且在标准中提供了<code>Object.getPrototypeOf</code>和<code>Object.setPrototypeOf</code>这两个方法分别用于访问和修改对象的<code>[[Prototype]]</code>属性。在下面的讲述中我们将使用ECMAScript 标准中的属性和方法来讨论JavaScript的原型链。</p><h2 id="构造函数与原型链" tabindex="-1">构造函数与原型链 <a class="header-anchor" href="#构造函数与原型链" aria-label="Permalink to &quot;构造函数与原型链&quot;">​</a></h2><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Man</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> tom </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Man</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>在上述代码中我们首先声明了一个函数<code>Man</code>，在JavaScript中如果在函数调用前使用<code>new</code>关键字那么该函数就变成了构造函数，函数调用就会返回该构造函数生成的实例对象。因此<code>Man</code>也是一个构造函数，所以在代码的第二行我们创建了<code>Man</code>的一个对象<code>tom</code>。通过之前的讲述，我们知道<code>tom</code>对象的<code>[[Prototype]]</code>属性保存了<code>tom</code>对象的原型。</p><p>一般来说所有通过<code>Man</code>函数创建的对象都应该共享同一个原型对象，因此该原型对象应该保存在对象的构造函数中。事实也确实如此构造函数的<code>prototype</code>属性就是所有通过此构造函数生成的对象的原型对象。因此<code>Object.getPrototypeOf(tom) === Man.prototype</code>。</p><p>既然可以通过构造函数访问对象的原型对象，那么也应该能通过原型对象访问到构造函数才对（因为构造函数和原型对象是一一对应的关系）。因此在JavaScript中原型对象的<code>constructor</code>属性指向了与原型对象相对应的构造函数。即<code>Object.getPrototypeOf(tom).constructor === Man</code>。</p>`,11)),s(t,{src:"./images/构造函数与原型链.svg",caption:"构造函数与原型链"}),a[1]||(a[1]=e('<h2 id="普通对象的原型链" tabindex="-1">普通对象的原型链 <a class="header-anchor" href="#普通对象的原型链" aria-label="Permalink to &quot;普通对象的原型链&quot;">​</a></h2><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> example </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {}</span></span></code></pre></div><p>上述代码中我们声明了一个普通对象<code>example</code>。下面我们分析一下这个普通对象<code>example</code>的原型链。</p><p>普通对象的构造函数为<code>Object</code>, 因此<code>example</code>对象的原型对象为<code>Object.prototype</code>。<code>Object.prototype</code>也是一个对象，它的原型对象为<code>null</code>。由此可知<code>Object.prototype</code>对象是一切对象的根对象。</p>',4)),s(t,{src:"./images/普通对象的原型链.svg",caption:"普通对象的原型链"}),a[2]||(a[2]=e(`<h2 id="函数对象的原型链" tabindex="-1">函数对象的原型链 <a class="header-anchor" href="#函数对象的原型链" aria-label="Permalink to &quot;函数对象的原型链&quot;">​</a></h2><p>在JavaScript中一切皆对象，函数也是对象，那么函数对象的原型链是什么呢？</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Man</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> tom </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Man</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>我们还以以上代码进行分析，我们已经知道了对象<code>tom</code>的原型为<code>Man.prototype</code>，那么<code>Man.prototype</code>的原型是什么呢？<code>Man.prototype</code>作为一个对象，是通过构造函数<code>Object</code>创建的，因此<code>Man.prototype</code>的原型是<code>Object.prototype</code>。即<code>Object.getPrototypeOf(Man.prototype) === Object.prototype</code>。因此<code>Man.prototype</code>的原型链为<code>Man.prototype --&gt; Object.prototype --&gt; null</code>。</p>`,4)),s(t,{src:"./images/原型的原型.svg",caption:"原型的原型"}),a[3]||(a[3]=e("<p>函数<code>Man</code>作为一个对象，那它的原型链是什么呢？在JavaScript中函数对象也有构造函数，函数对象的构造函数为<code>Function</code>。因此函数对象<code>Man</code>的原型为<code>Function.prototype</code>。<code>Function.prototype</code>对象作为一个普通对象，因此<code>Function.prototype</code>的原型为<code>Object.prototype</code>。所以函数对象<code>Man</code>的原型链为<code>Man --&gt; Function.prototype --&gt; Object.prototype --&gt; null</code>。</p>",1)),s(t,{src:"./images/函数对象的原型链.svg",caption:"函数对象的原型链"}),a[4]||(a[4]=e("<p>既然函数对象的构造函数<code>Function</code>也是一个对象那么<code>Function</code>对象的原型是什么呢？在JavaScript中，<code>Function</code>对象被认为是由<code>Function</code>构造函数生成的对象。因此<code>Function</code>对象的原型也是<code>Function.prototype</code>。即<code>Function</code>对象的原型链为<code>Function --&gt; Function.prototype --&gt; Object.prototype --&gt; null</code>。</p>",1)),s(t,{src:"./images/Function对象的原型链.svg",caption:"Function对象的原型链"}),a[5]||(a[5]=e(`<h2 id="es6中的继承与原型链" tabindex="-1">ES6中的继承与原型链 <a class="header-anchor" href="#es6中的继承与原型链" aria-label="Permalink to &quot;ES6中的继承与原型链&quot;">​</a></h2><p>在ES6中为了让JavaScript与主流的语言更接近推出了新的<code>class</code>语法用于对象编程。虽然使用了<code>class</code>语法但是本质上还是JavaScript以前的构造函数的语法糖。下面我们讨论一下再ES6中&quot;类&quot;与&quot;继承&quot;的原型链。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Human</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Man</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> extends</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Human</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> tom </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Man</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>上述代码中我们先声明了<code>Human</code>类，然后又声明了一个继承自<code>Human</code>类的<code>Man</code>类，最后再创造了一个<code>Man</code>类的实例对象<code>tom</code>。这里存在两条原型链。一条是: <code>tom --&gt; Man.prototype --&gt; Human.prototype --&gt; Object.prototype --&gt; null</code>，这个是实例对象的原型链。另一条是<code>Man --&gt; Human --&gt; Function.prototype --&gt; Object.prototype --&gt; null</code>, 这个是类对象的原型链。</p>`,4)),s(t,{src:"./images/类与继承的原型链.svg",caption:"类与继承的原型链"})])}const v=o(n,[["render",d]]);export{u as __pageData,v as default};
