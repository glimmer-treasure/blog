const t='{"documentCount":85,"nextId":85,"documentIds":{"0":"/drafts/2021-06-14-SEO实战.html#seo实战","1":"/drafts/2021-11-28-vue组件的单元测试.html#vue组件库的单元测试","2":"/drafts/2022-06-19-如何搭建自己的博客.html#如何搭建自己的博客","3":"/drafts/2022-06-19-如何搭建自己的博客.html#技术栈介绍","4":"/drafts/2022-06-19-如何搭建自己的博客.html#如何使用github-actions将自己的博客打包发布到阿里oss","5":"/drafts/2022-06-19-如何搭建自己的博客.html#name字段","6":"/drafts/2022-06-19-如何搭建自己的博客.html#on字段","7":"/drafts/2022-06-19-如何搭建自己的博客.html#jobs字段","8":"/drafts/2022-06-19-如何搭建自己的博客.html#job的id","9":"/drafts/2022-06-19-如何搭建自己的博客.html#runs-on","10":"/drafts/2022-06-19-如何搭建自己的博客.html#environment","11":"/drafts/2022-06-19-如何搭建自己的博客.html#steps","12":"/drafts/2022-06-19-如何搭建自己的博客.html#未完成待续","13":"/drafts/setState是异步更新还是同步更新.html#setstate是异步更新还是同步更新","14":"/drafts/setState是异步更新还是同步更新.html#结论","15":"/drafts/setState是异步更新还是同步更新.html#为什么","16":"/drafts/手写一个Promise.html#手写一个promise","17":"/drafts/手写一个Promise.html#promise骨架","18":"/drafts/手写一个Promise.html#promise的状态","19":"/drafts/手写一个Promise.html#promise-prototype-then函数","20":"/drafts/编译原理.html#编译原理","21":"/drafts/编译原理.html#_1-编译的整体过程","22":"/posts/HTTPS握手过程/#https学习小结","23":"/posts/HTTPS握手过程/#https是什么","24":"/posts/HTTPS握手过程/#https的作用","25":"/posts/HTTPS握手过程/#_1-身份认证","26":"/posts/HTTPS握手过程/#_2-加密通信","27":"/posts/HTTPS握手过程/#https握手过程","28":"/posts/HTTPS握手过程/#_1-rsa秘钥协商算法握手过程","29":"/posts/HTTPS握手过程/#_2-dh密钥协商算法握手过程","30":"/posts/HTTPS握手过程/#_3-rsa秘钥协商算法和dh秘钥协商算法的区别","31":"/posts/HTTPS握手过程/#_4-加密套件的作用","32":"/posts/HTTP从1到3/#http从1到3","33":"/posts/HTTP从1到3/#http从1-0到1-1","34":"/posts/HTTP从1到3/#http-1-0的缺点","35":"/posts/HTTP从1到3/#http-1-1的改进","36":"/posts/HTTP从1到3/#http从1-1到2","37":"/posts/HTTP从1到3/#http-1-1的缺点","38":"/posts/HTTP从1到3/#http-2的改进","39":"/posts/HTTP从1到3/#http从2到3","40":"/posts/HTTP从1到3/#http-2的缺点","41":"/posts/HTTP从1到3/#http-3的改进","42":"/posts/HTTP从1到3/#总结","43":"/posts/JavaScript中如何判断一个变量是否是对象/#javascript中如何判断一个变量是否是对象、数组","44":"/posts/JavaScript中如何判断一个变量是否是对象/#_1-基础知识","45":"/posts/JavaScript中如何判断一个变量是否是对象/#_1-1-javascript的变量类型","46":"/posts/JavaScript中如何判断一个变量是否是对象/#_1-2-使用typeof运算符","47":"/posts/JavaScript中如何判断一个变量是否是对象/#_1-3-javascript类型和typeof的对应关系","48":"/posts/JavaScript中如何判断一个变量是否是对象/#_2-如何判断一个变量是否为对象","49":"/posts/JavaScript中如何判断一个变量是否是对象/#_2-1-使用typeof进行判断","50":"/posts/JavaScript中如何判断一个变量是否是对象/#_2-2-使用object-prototype-tostring进行判断","51":"/posts/JavaScript中如何判断一个变量是否是对象/#_3-如何判断一个对象是否为空对象","52":"/posts/JavaScript中如何判断一个变量是否是对象/#_3-1-使用for-in-循环来判断","53":"/posts/JavaScript中如何判断一个变量是否是对象/#_3-2-使用object-keys方法判断","54":"/posts/JavaScript中如何判断一个变量是否是对象/#_3-3-使用object-getownpropertynames方法判断","55":"/posts/JavaScript中如何判断一个变量是否是对象/#_3-4-使用reflect-ownkeys方法判断","56":"/posts/JavaScript中如何判断一个变量是否是对象/#_4-如何判断一个变量是否是数组","57":"/posts/JavaScript中如何判断一个变量是否是对象/#_4-1-使用array-isarray方法","58":"/posts/JavaScript中如何判断一个变量是否是对象/#_4-2-使用object-prototype-tostring方法","59":"/posts/JavaScript中如何判断一个变量是否是对象/#_4-3-完美解决方案","60":"/posts/Javascript原型链总结/#javascript原型链总结","61":"/posts/Javascript原型链总结/#什么是原型链","62":"/posts/Javascript原型链总结/#与原型相关的属性-proto-与-prototype","63":"/posts/Javascript原型链总结/#构造函数与原型链","64":"/posts/Javascript原型链总结/#普通对象的原型链","65":"/posts/Javascript原型链总结/#函数对象的原型链","66":"/posts/Javascript原型链总结/#es6中的继承与原型链","67":"/posts/husky使用总结.html#husky使用总结","68":"/posts/husky使用总结.html#husky为什么放弃了之前的配置方式","69":"/posts/husky使用总结.html#新版husky的工作原理","70":"/posts/husky使用总结.html#新版husky实践","71":"/posts/husky使用总结.html#需要注意的点","72":"/posts/一文彻底搞懂ssh登录.html#一文彻底搞懂ssh登录","73":"/posts/一文彻底搞懂ssh登录.html#ssh是什么","74":"/posts/一文彻底搞懂ssh登录.html#ssh加密通信原理","75":"/posts/一文彻底搞懂ssh登录.html#ssh身份验证","76":"/posts/一文彻底搞懂ssh登录.html#_1-口令登录","77":"/posts/一文彻底搞懂ssh登录.html#_2-公钥登陆","78":"/posts/观察者模式与发布订阅模式/#观察者模式与发布订阅模式","79":"/posts/观察者模式与发布订阅模式/#观察者模式","80":"/posts/观察者模式与发布订阅模式/#发布订阅模式","81":"/posts/什么是闭包.html#什么是闭包","82":"/posts/什么是闭包.html#作用域与作用域链","83":"/posts/什么是闭包.html#闭包能够做什么","84":"/posts/什么是闭包.html#闭包的注意事项"},"fieldIds":{"title":0,"titles":1,"text":2},"fieldLength":{"0":[1,1,1],"1":[1,1,7],"2":[1,1,15],"3":[1,1,22],"4":[2,1,88],"5":[1,3,14],"6":[1,3,10],"7":[1,3,16],"8":[1,4,9],"9":[2,4,8],"10":[1,4,3],"11":[1,4,71],"12":[2,1,1],"13":[1,1,5],"14":[1,1,5],"15":[1,1,6],"16":[1,1,13],"17":[1,1,42],"18":[1,1,49],"19":[3,1,6],"20":[1,1,3],"21":[2,1,1],"22":[1,1,3],"23":[1,1,8],"24":[1,2,1],"25":[2,3,8],"26":[2,3,5],"27":[1,1,6],"28":[2,2,25],"29":[2,2,32],"30":[2,2,14],"31":[2,2,7],"32":[1,1,7],"33":[3,1,1],"34":[3,4,17],"35":[3,4,37],"36":[2,1,1],"37":[3,3,12],"38":[2,3,47],"39":[1,1,1],"40":[2,2,12],"41":[2,2,10],"42":[1,1,5],"43":[2,1,4],"44":[2,2,1],"45":[2,4,4],"46":[3,4,5],"47":[3,4,3],"48":[2,2,1],"49":[3,4,19],"50":[4,4,43],"51":[2,2,3],"52":[5,4,23],"53":[4,4,22],"54":[3,4,25],"55":[4,4,15],"56":[2,2,7],"57":[4,4,9],"58":[5,4,13],"59":[3,4,19],"60":[1,1,4],"61":[1,1,27],"62":[5,1,16],"63":[1,1,29],"64":[1,1,14],"65":[1,1,41],"66":[1,1,31],"67":[1,1,33],"68":[1,1,38],"69":[1,1,22],"70":[1,1,45],"71":[1,1,48],"72":[1,1,5],"73":[1,1,11],"74":[1,1,5],"75":[1,1,9],"76":[2,2,8],"77":[2,2,7],"78":[1,1,1],"79":[1,1,47],"80":[1,1,62],"81":[1,1,12],"82":[1,1,34],"83":[1,1,14],"84":[1,1,6]},"averageFieldLength":[1.776470588235294,1.9529411764705875,16.929411764705883],"storedFields":{"0":{"title":"SEO实战","titles":[]},"1":{"title":"vue组件库的单元测试","titles":[]},"2":{"title":"如何搭建自己的博客","titles":[]},"3":{"title":"技术栈介绍","titles":["如何搭建自己的博客"]},"4":{"title":"如何使用github actions将自己的博客打包发布到阿里oss","titles":["如何搭建自己的博客"]},"5":{"title":"name字段","titles":["如何搭建自己的博客","如何使用github actions将自己的博客打包发布到阿里oss"]},"6":{"title":"on字段","titles":["如何搭建自己的博客","如何使用github actions将自己的博客打包发布到阿里oss"]},"7":{"title":"jobs字段","titles":["如何搭建自己的博客","如何使用github actions将自己的博客打包发布到阿里oss"]},"8":{"title":"job的id","titles":["如何搭建自己的博客","如何使用github actions将自己的博客打包发布到阿里oss","jobs字段"]},"9":{"title":"runs-on","titles":["如何搭建自己的博客","如何使用github actions将自己的博客打包发布到阿里oss","jobs字段"]},"10":{"title":"environment","titles":["如何搭建自己的博客","如何使用github actions将自己的博客打包发布到阿里oss","jobs字段"]},"11":{"title":"steps","titles":["如何搭建自己的博客","如何使用github actions将自己的博客打包发布到阿里oss","jobs字段"]},"12":{"title":"未完成待续......","titles":["如何搭建自己的博客"]},"13":{"title":"setState是异步更新还是同步更新","titles":[]},"14":{"title":"结论","titles":["setState是异步更新还是同步更新"]},"15":{"title":"为什么","titles":["setState是异步更新还是同步更新"]},"16":{"title":"手写一个Promise","titles":[]},"17":{"title":"Promise骨架","titles":["手写一个Promise"]},"18":{"title":"Promise的状态","titles":["手写一个Promise"]},"19":{"title":"Promise.prototype.then函数","titles":["手写一个Promise"]},"20":{"title":"编译原理","titles":[]},"21":{"title":"1. 编译的整体过程","titles":["编译原理"]},"22":{"title":"HTTPS学习小结","titles":[]},"23":{"title":"HTTPS是什么","titles":["HTTPS学习小结"]},"24":{"title":"HTTPS的作用","titles":["HTTPS学习小结","HTTPS是什么"]},"25":{"title":"\\u00101. 身份认证","titles":["HTTPS学习小结","HTTPS是什么","HTTPS的作用"]},"26":{"title":"2. 加密通信","titles":["HTTPS学习小结","HTTPS是什么","HTTPS的作用"]},"27":{"title":"HTTPS握手过程","titles":["HTTPS学习小结"]},"28":{"title":"1. RSA秘钥协商算法握手过程","titles":["HTTPS学习小结","HTTPS握手过程"]},"29":{"title":"2. DH密钥协商算法握手过程","titles":["HTTPS学习小结","HTTPS握手过程"]},"30":{"title":"3. RSA秘钥协商算法和DH秘钥协商算法的区别","titles":["HTTPS学习小结","HTTPS握手过程"]},"31":{"title":"4. 加密套件的作用","titles":["HTTPS学习小结","HTTPS握手过程"]},"32":{"title":"HTTP从1到3","titles":[]},"33":{"title":"HTTP从1.0到1.1","titles":["HTTP从1到3"]},"34":{"title":"HTTP 1.0的缺点","titles":["HTTP从1到3","HTTP从1.0到1.1"]},"35":{"title":"HTTP 1.1的改进","titles":["HTTP从1到3","HTTP从1.0到1.1"]},"36":{"title":"HTTP从1.1到2","titles":["HTTP从1到3"]},"37":{"title":"HTTP 1.1的缺点","titles":["HTTP从1到3","HTTP从1.1到2"]},"38":{"title":"HTTP 2的改进","titles":["HTTP从1到3","HTTP从1.1到2"]},"39":{"title":"HTTP从2到3","titles":["HTTP从1到3"]},"40":{"title":"HTTP 2的缺点","titles":["HTTP从1到3","HTTP从2到3"]},"41":{"title":"HTTP 3的改进","titles":["HTTP从1到3","HTTP从2到3"]},"42":{"title":"总结","titles":["HTTP从1到3"]},"43":{"title":"JavaScript中如何判断一个变量是否是对象、数组","titles":[]},"44":{"title":"1. 基础知识","titles":["JavaScript中如何判断一个变量是否是对象、数组"]},"45":{"title":"1.1  JavaScript的变量类型","titles":["JavaScript中如何判断一个变量是否是对象、数组","1. 基础知识"]},"46":{"title":"1.2 使用typeof运算符","titles":["JavaScript中如何判断一个变量是否是对象、数组","1. 基础知识"]},"47":{"title":"1.3 JavaScript类型和typeof的对应关系","titles":["JavaScript中如何判断一个变量是否是对象、数组","1. 基础知识"]},"48":{"title":"2. 如何判断一个变量是否为对象","titles":["JavaScript中如何判断一个变量是否是对象、数组"]},"49":{"title":"2.1 使用typeof进行判断","titles":["JavaScript中如何判断一个变量是否是对象、数组","2. 如何判断一个变量是否为对象"]},"50":{"title":"2.2 使用Object.prototype.toString进行判断","titles":["JavaScript中如何判断一个变量是否是对象、数组","2. 如何判断一个变量是否为对象"]},"51":{"title":"3. 如何判断一个对象是否为空对象","titles":["JavaScript中如何判断一个变量是否是对象、数组"]},"52":{"title":"3.1 使用for in 循环来判断","titles":["JavaScript中如何判断一个变量是否是对象、数组","3. 如何判断一个对象是否为空对象"]},"53":{"title":"3.2 使用Object.keys方法判断","titles":["JavaScript中如何判断一个变量是否是对象、数组","3. 如何判断一个对象是否为空对象"]},"54":{"title":"3.3 使用Object.getOwnPropertyNames方法判断","titles":["JavaScript中如何判断一个变量是否是对象、数组","3. 如何判断一个对象是否为空对象"]},"55":{"title":"3.4 使用Reflect.ownKeys方法判断","titles":["JavaScript中如何判断一个变量是否是对象、数组","3. 如何判断一个对象是否为空对象"]},"56":{"title":"4. 如何判断一个变量是否是数组","titles":["JavaScript中如何判断一个变量是否是对象、数组"]},"57":{"title":"4.1 使用Array.isArray方法","titles":["JavaScript中如何判断一个变量是否是对象、数组","4. 如何判断一个变量是否是数组"]},"58":{"title":"4.2 使用Object.prototype.toString方法","titles":["JavaScript中如何判断一个变量是否是对象、数组","4. 如何判断一个变量是否是数组"]},"59":{"title":"4.3 完美解决方案","titles":["JavaScript中如何判断一个变量是否是对象、数组","4. 如何判断一个变量是否是数组"]},"60":{"title":"JavaScript原型链总结","titles":[]},"61":{"title":"什么是原型链","titles":["JavaScript原型链总结"]},"62":{"title":"与原型相关的属性（__proto__与[[Prototype]]）","titles":["JavaScript原型链总结"]},"63":{"title":"构造函数与原型链","titles":["JavaScript原型链总结"]},"64":{"title":"普通对象的原型链","titles":["JavaScript原型链总结"]},"65":{"title":"函数对象的原型链","titles":["JavaScript原型链总结"]},"66":{"title":"ES6中的继承与原型链","titles":["JavaScript原型链总结"]},"67":{"title":"husky使用总结","titles":[]},"68":{"title":"husky为什么放弃了之前的配置方式","titles":["husky使用总结"]},"69":{"title":"新版husky的工作原理","titles":["husky使用总结"]},"70":{"title":"新版husky实践","titles":["husky使用总结"]},"71":{"title":"需要注意的点","titles":["husky使用总结"]},"72":{"title":"一文彻底搞懂ssh登录","titles":[]},"73":{"title":"SSH是什么","titles":["一文彻底搞懂ssh登录"]},"74":{"title":"SSH加密通信原理","titles":["一文彻底搞懂ssh登录"]},"75":{"title":"SSH身份验证","titles":["一文彻底搞懂ssh登录"]},"76":{"title":"1. 口令登录","titles":["一文彻底搞懂ssh登录","SSH身份验证"]},"77":{"title":"2. 公钥登陆","titles":["一文彻底搞懂ssh登录","SSH身份验证"]},"78":{"title":"观察者模式与发布订阅模式","titles":[]},"79":{"title":"观察者模式","titles":["观察者模式与发布订阅模式"]},"80":{"title":"发布订阅模式","titles":["观察者模式与发布订阅模式"]},"81":{"title":"什么是闭包","titles":[]},"82":{"title":"作用域与作用域链","titles":["什么是闭包"]},"83":{"title":"闭包能够做什么","titles":["什么是闭包"]},"84":{"title":"闭包的注意事项","titles":["什么是闭包"]}},"dirtCount":0,"index":[["主要是因为通过闭包我们延长了一些变量的生命周期",{"2":{"84":1}}],["防抖和节流",{"2":{"83":1}}],["延长变量的生命周期",{"2":{"83":1}}],["代码的模块化",{"2":{"83":1}}],["代码如下",{"2":{"54":1,"57":1,"80":1}}],["代码如下所示",{"2":{"49":1,"50":1}}],["闭包的注意事项",{"0":{"84":1}}],["闭包能够做什么",{"0":{"83":1}}],["闭包函数",{"2":{"81":1}}],["答案是使用闭包函数",{"2":{"82":1}}],["答案是不能",{"2":{"82":1}}],["答案很简单因为随着互联网的发展旧版的http出现了令人无法忍受的缺陷所以我们要推出新的http来修复旧版本的缺陷使得http能够更好的适应互联网的发展",{"2":{"32":1}}],["可见变量的查找是按照作用域链进行查找的",{"2":{"82":1}}],["可以看到该脚本的功能就是执行npm",{"2":{"70":1}}],["可以使用object",{"2":{"54":1}}],["变量的访问规则指的是在一个作用域中访问一个变量javascript引擎会现在当前作用域查找变量是否存在",{"2":{"82":1}}],["变量的生命周期指的是当我们在一个作用域中声明了一个变量",{"2":{"82":1}}],["访问的函数",{"2":{"81":1}}],["特指函数作用域",{"2":{"81":1}}],["什么是闭包",{"0":{"81":1},"1":{"82":1,"83":1,"84":1}}],["什么是原型链",{"0":{"61":1},"2":{"61":1}}],["至于哪个订阅者订阅了发布者以及如何通知订阅者则统统交给事件总线进行处理",{"2":{"80":1}}],["至于订阅和管理观察者的功能",{"2":{"80":1}}],["功能",{"2":{"80":1}}],["仅保留发布",{"2":{"80":1}}],["目标对象",{"2":{"80":2}}],["目标对象的订阅功能和对观察者的管理功能被删除",{"2":{"80":1}}],["目录并指定该目录为git",{"2":{"70":1}}],["目录下新增了一个名为pre",{"2":{"70":1}}],["目录下",{"2":{"69":1}}],["人们提出发布订阅模式",{"2":{"80":1}}],["发布订阅模式",{"0":{"80":1}}],["发送者收到确认消息后才会发送下一个报文",{"2":{"40":1}}],["发送所用http请求来解决这个问题",{"2":{"38":1}}],["来存放所有订阅了该目标对象的观察者们",{"2":{"79":1}}],["两个方法还要有一个属性",{"2":{"79":1}}],["和",{"2":{"79":1}}],["和dh算法参数",{"2":{"29":1}}],["收集和管理观察者",{"2":{"79":1}}],["还要有一个方法去收集所有订阅了该目标对象的观察者",{"2":{"79":1}}],["还有身份验证功能",{"2":{"75":1}}],["观察者",{"2":{"80":1}}],["观察者功能不变",{"2":{"80":1}}],["观察者对象订阅目标对象",{"2":{"79":1}}],["观察者模式",{"0":{"79":1}}],["观察者模式与发布订阅模式",{"0":{"78":1},"1":{"79":1,"80":1}}],["远程主机地址",{"2":{"76":1}}],["远程主机用户名",{"2":{"76":1}}],["口令登录",{"0":{"76":1}}],["证书登录",{"2":{"75":1}}],["证书验证通过后客户端生成随机数r3",{"2":{"28":1}}],["公钥登陆过程",{"2":{"77":1}}],["公钥登陆",{"0":{"77":1},"2":{"75":1}}],["原理很简单就是首先通过握手阶段使通信双方分别得到一个相同的秘钥",{"2":{"74":1}}],["原型链就是javascript语言中实现继承的方式",{"2":{"61":1}}],["说到加密通信",{"2":{"74":1}}],["说起http的版本变迁",{"2":{"32":1}}],["感觉作用跟https类似",{"2":{"73":1}}],["感谢知乎用户",{"2":{"71":1}}],["是一种网络协议",{"2":{"73":1}}],["是通过构造函数object创建的",{"2":{"65":1}}],["于是今天就写了这篇文章来总结一下ssh",{"2":{"72":1}}],["于是便提出了http",{"2":{"37":1}}],["自己用ssh也已经很长时间了但是从来没有深入的了解过其原理",{"2":{"72":1}}],["希望有知道的大神能够告诉我一下",{"2":{"71":1}}],["参数表示强制npx使用项目中node",{"2":{"71":1}}],["取而代之的是$1",{"2":{"71":1}}],["需要注意的点",{"0":{"71":1}}],["需要注意的是在长链接模式下浏览器创建tcp连接的策略是对不同域名的请求浏览器会使用不同tcp连接",{"2":{"35":1}}],["运行完该命令后我们会看到",{"2":{"70":1}}],["运行一下命令创建git",{"2":{"70":1}}],["添加git",{"2":{"70":1}}],["该函数创建的作用域也不会销毁",{"2":{"82":1}}],["该命令会创建",{"2":{"70":1}}],["该方法不仅返回正常的属性名",{"2":{"55":1}}],["该方法无法获取到用symbol表示的属性",{"2":{"54":1}}],["该方法是object",{"2":{"54":1}}],["该方法会判断错误",{"2":{"52":1}}],["安装husky",{"2":{"70":1}}],["安装依赖",{"2":{"11":1}}],["中添加hook",{"2":{"69":1}}],["中配置相对应的git",{"2":{"68":1}}],["9开始引入的一个新功能core",{"2":{"69":1}}],["新版husky实践",{"0":{"70":1}}],["新版husky的工作原理",{"0":{"69":1}}],["新版的husky使用了从git",{"2":{"69":1}}],["究其失败的根本原因",{"2":{"68":1}}],["作用域和作用域链规定了javascript中变量的生命周期和变量的访问规则",{"2":{"82":1}}],["作用域与作用域链",{"0":{"82":1}}],["作者认为这个问题是由husky工作模型的自身缺陷导致的",{"2":{"68":1}}],["作者无法找到一个可靠的方法来同步这两个地方的配置",{"2":{"68":1}}],["作者尝试过解决这个问题",{"2":{"68":1}}],["作为补充",{"2":{"54":1}}],["作为一个使用过react的人",{"2":{"13":1}}],["作为公司前端项目的公共组件库任何一点小错误都有可能造成公司的所有业务项目出错",{"2":{"1":1}}],["工作的每个阶段都会调用husky所设置的脚本",{"2":{"68":1}}],["根据官方的说法",{"2":{"68":1}}],["根据秘钥协商算法的不同握手的具体过程也不一样",{"2":{"27":1}}],["之后自动执行",{"2":{"70":1}}],["之前husky的工作方式是这样的",{"2":{"68":1}}],["之前的设置方式已经失效了",{"2":{"67":1}}],["之所以使用object",{"2":{"50":1}}],["之所以进行替换主要还是因为github",{"2":{"3":1}}],["已经做了破坏性的变更",{"2":{"67":1}}],["6",{"2":{"67":1}}],["经过一番查看才知道原来最新版本的husky",{"2":{"67":1}}],["校验commit时添加的备注信息是否符合我们要求的规范",{"2":{"67":1,"71":1}}],["将husky添加到项目的开发依赖中",{"2":{"67":1}}],["通知",{"2":{"80":1}}],["通常情况下我只需要如下两步就可在项目中引入并设置好husky",{"2":{"67":1}}],["通过以上的讲解我们知道如果闭包函数中有对函数作用域中变量的访问",{"2":{"83":1}}],["通过以上的内容我们已经知道了什么是闭包函数",{"2":{"83":1}}],["通过身份验证功能我们才能远程登录我们的云主机",{"2":{"75":1}}],["通过这种方式我们就可以只添加我们需要的git",{"2":{"69":1}}],["通过之前的讲述",{"2":{"63":1}}],["通过之前的讲解",{"2":{"49":1}}],["通过修改tcp来修复这个问题显然是不切实际的",{"2":{"41":1}}],["通过上图我们可以看到虽然在tcp连接中二进制帧是串行发送的",{"2":{"38":1}}],["通过上面的介绍我们知道之所以会产生在同一tcp连接中请求队列阻塞的问题是因为在http",{"2":{"38":1}}],["通过上面的讲述我们已经知道了在javascript中变量的访问规则",{"2":{"82":1}}],["通过上面的讲述",{"2":{"37":1}}],["通过握手过程我们可以看到最终的会话秘钥是由r1",{"2":{"30":1}}],["通过promises",{"2":{"16":1}}],["另一条是man",{"2":{"66":1}}],["另一种是使用object",{"2":{"56":1}}],["继承",{"2":{"66":1}}],["类",{"2":{"66":1}}],["quot",{"2":{"66":4,"70":2,"71":4}}],["既然函数对象的构造函数function也是一个对象那么function对象的原型是什么呢",{"2":{"65":1}}],["既然可以通过构造函数访问对象的原型对象",{"2":{"63":1}}],["那就是目标对象不仅要实现一个方法去通知观察者",{"2":{"79":1}}],["那有没有可能让husky只添加我们需要的git",{"2":{"68":1}}],["那它的原型链是什么呢",{"2":{"65":1}}],["那么即使函数运行结束",{"2":{"83":1}}],["那么即使其中一条请求出现延迟也不会影响到其他的请求",{"2":{"38":1}}],["那么闭包函数能够做什么呢",{"2":{"83":1}}],["那么我们就可以在函数的父作用域中得到这个访问函数",{"2":{"82":1}}],["那么如何才能访问到子作用域中的变量呢",{"2":{"82":1}}],["那么如何来实现对空对象的判断呢",{"2":{"51":1}}],["那么不难看出如果在父作用域中定义一个变量",{"2":{"82":1}}],["那么当代码运行到此作用域中这个变量会随之创建",{"2":{"82":1}}],["那么作用域和作用域链有什么作用呢",{"2":{"82":1}}],["那么今天我们讲一讲什么是闭包",{"2":{"81":1}}],["那么man",{"2":{"65":1}}],["那么函数对象的原型链是什么呢",{"2":{"65":1}}],["那么也应该能通过原型对象访问到构造函数才对",{"2":{"63":1}}],["那么就去原型对象的原型对象上找此属性",{"2":{"61":1}}],["那么就会去该对象的原型对象上去找此属性",{"2":{"61":1}}],["那么就会去父类上找该属性",{"2":{"61":1}}],["那么就返回null",{"2":{"61":1}}],["那么就是一个空对象",{"2":{"53":1}}],["那么之后的所有二进制帧都不能再被发送了",{"2":{"40":1}}],["那么这个promise实例的状态将会变为rejected",{"2":{"17":1}}],["函数作用域也不会被销毁",{"2":{"83":1}}],["函数对象的构造函数为function",{"2":{"65":1}}],["函数对象的原型链",{"0":{"65":1}}],["函数man作为一个对象",{"2":{"65":1}}],["函数也是对象",{"2":{"65":1}}],["函数调用就会返回该构造函数生成的实例对象",{"2":{"63":1}}],["普通对象的构造函数为object",{"2":{"64":1}}],["普通对象的原型链",{"0":{"64":1}}],["事实也确实如此构造函数的prototype属性就是所有通过此构造函数生成的对象的原型对象",{"2":{"63":1}}],["构造函数与原型链",{"0":{"63":1}}],["构建博客",{"2":{"8":1}}],["标准中的属性和方法来讨论javascript的原型链",{"2":{"62":1}}],["标准中对象",{"2":{"62":1}}],["的解耦",{"2":{"80":1}}],["的功能也实现了发布者",{"2":{"80":1}}],["的缩写",{"2":{"73":1}}],["的原型链",{"2":{"66":1}}],["的属性用于指定对象的原型",{"2":{"62":1}}],["的所有二进制帧组成了一个流",{"2":{"38":1}}],["但这是一个非标准属性",{"2":{"62":1}}],["但是如果在子作用域中定义一个变量我们能在父作用域中访问到吗",{"2":{"82":1}}],["但是如果问什么是闭包可能很多人都回答不上来",{"2":{"81":1}}],["但是目标对象不符合单一职责原则",{"2":{"79":1}}],["但是由于本人对shell编程不熟",{"2":{"71":1}}],["但是由于还有其他的队列在正常发送不至于该域名下的所有请求都无法得到响应",{"2":{"35":1}}],["但是失败了",{"2":{"68":1}}],["但是缺点也是显而易见的",{"2":{"68":1}}],["但是今天在我新建的项目中这样设置竟然不起作用了",{"2":{"67":1}}],["但是与object",{"2":{"54":1}}],["但是这个方法并非完美",{"2":{"52":1}}],["但是在使用中还是要注意和小心的",{"2":{"84":1}}],["但是在实现过程中有一个问题",{"2":{"79":1}}],["但是在有些情况下我们只是想判断一个变量是否是",{"2":{"50":1}}],["但是在settimeout",{"2":{"14":1}}],["但是使用typeof有一个问题如下所示",{"2":{"50":1}}],["但是并不代表每个版本只有对上个版本这方面的改进",{"2":{"42":1}}],["但是我们知道tcp是面向连接可靠传输的协议",{"2":{"40":1}}],["但是我们在宏观上看请求就是像是在并行发送一样",{"2":{"38":1}}],["但是为了避免因为当前请求迟迟无法响应导致后续请求无法发出的情况",{"2":{"37":1}}],["但是只有当上个请求收到响应后才发送下一个请求的串行发送方式并不完美",{"2":{"35":1}}],["但是随着web页面http请求的增多",{"2":{"34":1}}],["但是似乎都没有看到有使用的地方",{"2":{"31":1}}],["但是dh秘钥协商算法不同",{"2":{"30":1}}],["但是r3毕竟是通过不安全的信道发送出去了",{"2":{"30":1}}],["属性保存了tom对象的原型",{"2":{"63":1}}],["属性",{"2":{"62":1}}],["属性指向该对象的原型",{"2":{"62":1}}],["属于同一请求的每个二进制帧会携带相同的流id",{"2":{"38":1}}],["熟悉javascript的同学都知道",{"2":{"62":1}}],["与订阅者",{"2":{"80":1}}],["与",{"0":{"62":1},"2":{"66":1}}],["与原型相关的属性",{"0":{"62":1}}],["由此可知object",{"2":{"64":1}}],["由以上可知",{"2":{"61":1}}],["由于这个访问函数的存在",{"2":{"82":1}}],["由于这套系统已经运行了一年有余很多重要的操作和概念早已忘记的一干二净",{"2":{"2":1}}],["由于是只能遍历可枚举属性",{"2":{"52":1}}],["由于是不可靠传输所以即使出现报文丢失的情况也不会阻塞其他报文的发送",{"2":{"41":1}}],["由于",{"2":{"52":1}}],["或者一直没有找到则返回null",{"2":{"61":1}}],["或者直到基类仍没有找到该属性",{"2":{"61":1}}],["直到找到此属性为止",{"2":{"61":1}}],["直到收到确认消息或者等待超时后重新发送报文",{"2":{"40":1}}],["就是因为husky需要在两个地方进行配置才能完成一个完整的git",{"2":{"68":1}}],["就是通过在一条tcp连接上并发",{"2":{"38":1}}],["就会去父类的父类上找",{"2":{"61":1}}],["任何包含对象的语言都有继承这一特性",{"2":{"61":1}}],["形成一个完美的解决方案",{"2":{"59":1}}],["完美解决方案",{"0":{"59":1}}],["判断一个变量是否数组有两种比较完美的方法",{"2":{"56":1}}],["也是javascript语言中对象属性的访问机制",{"2":{"61":1}}],["也返回不可枚举属性以及symbol属性",{"2":{"55":1}}],["也就是三种登录远程主机的方法",{"2":{"75":1}}],["也就是说目标对象不仅要能通知观察者还要能够管理观察者",{"2":{"79":1}}],["也就是说在在执行git",{"2":{"70":1}}],["也就是说当我们执行npm",{"2":{"70":1}}],["也就是说无论是添加还是删除git",{"2":{"68":1}}],["也就是说我们要先建立tcp连接才能进行http通信",{"2":{"34":1}}],["也就是说执行顺序是这样的",{"2":{"7":1}}],["也就是说多个job之间默认是并行执行的",{"2":{"7":1}}],["也就说是一个完整的http请求",{"2":{"38":1}}],["缺点",{"2":{"52":1,"53":1,"54":1}}],["上述代码中我们先声明了human类",{"2":{"66":1}}],["上述代码中我们声明了一个普通对象example",{"2":{"64":1}}],["上的属性全部为不可枚举所以for",{"2":{"52":1}}],["上图为promises",{"2":{"18":1}}],["循环会遍历当前对象和对象原型上的可枚举属性",{"2":{"52":1}}],["循环来判断",{"0":{"52":1}}],["fn",{"2":{"79":4,"80":4}}],["filter",{"2":{"79":1,"80":1}}],["function对象被认为是由function构造函数生成的对象",{"2":{"65":1}}],["function",{"2":{"65":3,"66":1}}],["fulfilled",{"2":{"17":4,"18":4}}],["false",{"2":{"52":1}}],["foreach",{"2":{"79":1,"80":1}}],["for",{"2":{"52":2}}],["x26",{"2":{"49":2,"54":2}}],["进行判断",{"2":{"49":1}}],["时该变量可能是object也可能null",{"2":{"49":1}}],["返回",{"2":{"49":1}}],["表示未经计算的操作数的类型",{"2":{"46":1}}],["表示该job运行在最新的ubuntu系统中",{"2":{"9":1}}],["操作符返回一个字符串",{"2":{"46":1}}],["使用该命令后再键入密码即可登录成功",{"2":{"76":1}}],["使用了这个协议那么计算机之间的通信内容就不在是明文了",{"2":{"73":1}}],["使用array",{"0":{"57":1}}],["使用reflect",{"0":{"55":1},"2":{"55":1}}],["使用for",{"0":{"52":1}}],["使用object",{"0":{"50":1,"53":1,"54":1,"58":1}}],["使用typeof进行判断",{"0":{"49":1}}],["使用typeof运算符",{"0":{"46":1}}],["使用电脑自动打包和发布项目其实就是ci",{"2":{"4":1}}],["到目前为止javascript总共有8中类型",{"2":{"45":1}}],["基础知识",{"0":{"44":1},"1":{"45":1,"46":1,"47":1}}],["数组的问题",{"2":{"43":1}}],["数组",{"0":{"43":1},"1":{"44":1,"45":1,"46":1,"47":1,"48":1,"49":1,"50":1,"51":1,"52":1,"53":1,"54":1,"55":1,"56":1,"57":1,"58":1,"59":1}}],["整篇文章以如何提高tcp连接的利用率以及如何解决队头阻塞为线索依次讲述http",{"2":{"42":1}}],["整个连接就会进入等待状态",{"2":{"40":1}}],["总体来说当发布者状态改变时只需要发出相应的事件给事件总线",{"2":{"80":1}}],["总结",{"0":{"42":1}}],["总的来说技术栈就是hexo+github",{"2":{"3":1}}],["因为随着子作用域的结束该变量也被销毁了",{"2":{"82":1}}],["因为该变量还未被创建",{"2":{"82":1}}],["因为父作用域的存活时间一定长于子作用域",{"2":{"82":1}}],["因为构造函数和原型对象是一一对应的关系",{"2":{"63":1}}],["因为是无连接的协议所以在发送时不必经过握手过程所以省去了http2中tcp的握手时间",{"2":{"41":1}}],["因此会造成与观察者对象耦合度较高的问题",{"2":{"79":1}}],["因此也就不存在同步文件的问题了",{"2":{"69":1}}],["因此新版husky做了破坏性的变更",{"2":{"68":1}}],["因此失败了",{"2":{"68":1}}],["因此function对象的原型也是function",{"2":{"65":1}}],["因此function",{"2":{"65":1}}],["因此函数对象man的原型为function",{"2":{"65":1}}],["因此man",{"2":{"65":2}}],["因此man也是一个构造函数",{"2":{"63":1}}],["因此example对象的原型对象为object",{"2":{"64":1}}],["因此在javascript中原型对象的constructor属性指向了与原型对象相对应的构造函数",{"2":{"63":1}}],["因此在java与c++中访问一个对象的属性",{"2":{"61":1}}],["因此object",{"2":{"63":1}}],["因此该原型对象应该保存在对象的构造函数中",{"2":{"63":1}}],["因此如果数组长度为0",{"2":{"53":1}}],["因此我们可以获取一个对象自身的属性",{"2":{"53":1}}],["因此我们可以使用for",{"2":{"52":1}}],["因此我们可以先判断变量是否为null",{"2":{"49":1}}],["因此http",{"2":{"41":1}}],["因此流是双向",{"2":{"38":1}}],["因此看起来更安全一些",{"2":{"30":1}}],["因此本文主要详细叙述这两种秘钥协商算法的握手过程",{"2":{"27":1}}],["因此可以通过name字段来区分不同的workflow",{"2":{"5":1}}],["因此",{"2":{"1":1}}],["造成http",{"2":{"41":1}}],["否则就会一直等待",{"2":{"40":1}}],["接下来服务器会把请求对应的响应也切成二进制帧并带上流id通过tcp发送给客户端",{"2":{"38":1}}],["接下来使用run指定在操作系统的shell中运行的命令",{"2":{"11":1}}],["会根据帧上的流id区分接收到的帧属于哪个请求",{"2":{"38":1}}],["同一域名下的所有请求首先是被编码成二级制数据",{"2":{"38":1}}],["同时在github对应的项目的actions面板中可以看到该名称的workflow",{"2":{"5":1}}],["便是一个流",{"2":{"38":1}}],["请求+响应",{"2":{"38":2}}],["流",{"2":{"38":1}}],["一种能够跨作用域",{"2":{"81":1}}],["一种是使用array",{"2":{"56":1}}],["一文彻底搞懂ssh登录",{"0":{"72":1},"1":{"73":1,"74":1,"75":1,"76":1,"77":1}}],["一条是",{"2":{"66":1}}],["一般来说所有通过man函数创建的对象都应该共享同一个原型对象",{"2":{"63":1}}],["一个是在",{"2":{"68":1}}],["一个是在package",{"2":{"68":1}}],["一个是作用域链一个是原型链",{"2":{"60":1}}],["一个http请求报文可以被切片成多个帧从而在tcp连接上一帧一帧的发送",{"2":{"38":1}}],["一样也是返回对象自身的属性名所构成的数组",{"2":{"54":1}}],["一次完整的http请求",{"2":{"38":1}}],["一旦代码执行出错我们就需要将mypromise实例转变为rejected状态",{"2":{"18":1}}],["二进制帧就是将一整块二进制数据进行切片",{"2":{"38":1}}],["二进制帧",{"2":{"38":1}}],["二进制传输",{"2":{"38":1}}],["所有的http请求不再是一明文的方式传输而是以二级制的方式进行传输",{"2":{"38":1}}],["所以这里问的是什么是闭包函数",{"2":{"81":1}}],["所以一直没有成功",{"2":{"71":1}}],["所以函数对象man的原型链为man",{"2":{"65":1}}],["所以并不是很完美",{"2":{"53":1}}],["所以如果一个对象上只有不可枚举属性的话",{"2":{"52":1}}],["所以我们要显示的去调用object",{"2":{"50":1}}],["所以我们的mypromise类骨架如下",{"2":{"17":1}}],["所以会话秘钥安全性的关键在于r3不能被窃取",{"2":{"30":1}}],["所以根据规范所述",{"2":{"18":1}}],["所以顺理成章的就使用了hexo",{"2":{"3":1}}],["所以在代码的第二行我们创建了man的一个对象tom",{"2":{"63":1}}],["所以在本次替换结束后我写下该篇文章用以记录和总结这次替换的过程",{"2":{"2":1}}],["所以在替换过程中不得不重新翻看资料进行学习",{"2":{"2":1}}],["所以在开发和维护过程中可谓是压力山大",{"2":{"1":1}}],["下面我们讨论一下再es6中",{"2":{"66":1}}],["下面我们分析一下这个普通对象example的原型链",{"2":{"64":1}}],["下面我们来讲一下http",{"2":{"38":1}}],["下面我们将根据promises",{"2":{"16":1}}],["逻辑上的并行",{"2":{"38":1}}],["不知道如何将$1当成一个普通的字符串输出的文件中去",{"2":{"71":1}}],["不带参数",{"2":{"70":1}}],["不会遍历到任何属性",{"2":{"52":1}}],["不得不做出妥协",{"2":{"37":1}}],["不幸的是阿里云主机今年已经到期所以不得不将gitlab",{"2":{"2":1}}],["浏览器允许同一域名下最多创建6个tcp连接",{"2":{"35":1}}],["从这段代码中我们可以看到目标对象实现了",{"2":{"79":1}}],["从1到3的协议变迁过程",{"2":{"42":1}}],["从而将损失降到最小",{"2":{"35":1}}],["从而造成请求阻塞",{"2":{"35":1}}],["从上图我们可以看到相比于http",{"2":{"35":1}}],["从上面的过程中我们可以发现在dh秘钥协商算法下r3是不会通过信道发送出去的",{"2":{"30":1}}],["虽然闭包有很多用处",{"2":{"84":1}}],["虽然观察者模式很好",{"2":{"79":1}}],["虽然使用了class语法但是本质上还是javascript以前的构造函数的语法糖",{"2":{"66":1}}],["虽然判断是否为数组类型使用array",{"2":{"59":1}}],["虽然在http",{"2":{"35":1}}],["虽然用起来问题不大但显得有点落后",{"2":{"4":1}}],["对于commit",{"2":{"71":1}}],["对于判断一个变量是不是一个纯对象",{"2":{"50":1}}],["对于同一个域名下的请求浏览器会对请求进行排队依次通过tcp连接进行发送",{"2":{"35":1}}],["对于前端开发人员来说十分熟悉",{"2":{"3":1}}],["对同一域名下的请求浏览器会使用同一个tcp连接",{"2":{"35":1}}],["降低了用户的等待时间",{"2":{"35":1}}],["避免在请求过程中多次创建和断开tcp连接",{"2":{"35":1}}],["keep",{"2":{"35":1}}],["keys方法不同的一点是该方法可以获取到不可枚举属性",{"2":{"54":1}}],["keys方法的改进",{"2":{"54":1}}],["keys方法也只返回可枚举属性",{"2":{"53":1}}],["keys方法判断",{"0":{"53":1}}],["keys能返回对象自身上所有可枚举属性的名称所构成的数组",{"2":{"53":1}}],["keys",{"2":{"53":1}}],["key",{"2":{"4":2,"11":2}}],["针对这一缺点",{"2":{"35":1}}],["毕竟tcp的三次握手还是很耗时间的",{"2":{"34":1}}],["毕竟让服务器自动打包发布比自己手动执行命令看起来要高大上的多",{"2":{"4":1}}],["每一个流都用一个整数id来标识",{"2":{"38":1}}],["每次请求都要建立tcp连接不仅浪费tcp资源而且还增加了用户的等待时间",{"2":{"34":1}}],["每个job都需要一个唯一的id用于标识自己",{"2":{"8":1}}],["首先就会想到为什么http会从1进化到3",{"2":{"32":1}}],["首先是通过证书验证服务器的可靠性",{"2":{"28":1}}],["首先是name字段如下所示",{"2":{"5":1}}],["今天对原型链做一个总结",{"2":{"60":1}}],["今天我来总结一下",{"2":{"43":1}}],["今天就从http协议的版本讲起",{"2":{"32":1}}],["今天尝试写一篇文章彻底搞懂这个协议",{"2":{"22":1}}],["密码套件中记录了通信双方要使用何种秘钥协商算法以及最终通行过程中要使用哪种对称加密算法等等信息",{"2":{"31":1}}],["只有当上一个请求收到响应后才会让取出队列中的下一个请求进行发送",{"2":{"35":1}}],["只有通过加密套件计算机才能知道如何进行秘钥交换和通信的加解密操作",{"2":{"31":1}}],["只有处于pending状态的mypromise实例才能继续改变状态",{"2":{"18":1}}],["只是在传来传去",{"2":{"31":1}}],["4",{"0":{"31":1,"55":1,"56":1,"57":1,"58":1,"59":1},"1":{"57":1,"58":1,"59":1}}],["它的原型对象为null",{"2":{"64":1}}],["它没有采用基于类的继承实现方式",{"2":{"61":1}}],["它是由通信双方分别计算得到了",{"2":{"30":1}}],["它表示了这个workflow的名称",{"2":{"5":1}}],["3内部自己实现",{"2":{"41":1}}],["3底层不再采用tcp来传输数据而是使用无连接和不可靠传输的udp来发送数据",{"2":{"41":1}}],["3的改进",{"0":{"41":1}}],["3",{"0":{"30":1,"47":1,"51":1,"52":1,"53":1,"54":2,"55":1,"59":1},"1":{"52":1,"53":1,"54":1,"55":1},"2":{"50":1}}],["双方使用会话秘钥加解密之后的通行内容",{"2":{"29":1}}],["握手阶段结束",{"2":{"29":1}}],["用于加密两台计算机之间的通信",{"2":{"73":1}}],["用自己dh算法私钥以及客户端dh算法公钥和dh算法参数算出r3",{"2":{"29":1}}],["用户会先获取服务器的证书来验证当前通信的对象是否是服务器",{"2":{"25":1}}],["用户以为自己是在和服务器通信",{"2":{"25":1}}],["并用会话秘钥k解密客户端发来的加密信息",{"2":{"29":1}}],["并将加密后的dh算法参数和dh算法公钥发送给客户端",{"2":{"29":1}}],["并且支持各种身份验证机制",{"2":{"73":1}}],["并且在标准中提供了object",{"2":{"62":1}}],["并且有一个reason",{"2":{"18":1}}],["并且有一个value",{"2":{"18":1}}],["并且这个函数需要接收promise实例提供的resolve和reject这两个函数作为参数",{"2":{"17":1}}],["dirname",{"2":{"70":1,"71":1}}],["d",{"2":{"67":1,"70":1}}],["date这样的内置的构造函数所返回的对象也能通过判断",{"2":{"50":1}}],["date",{"2":{"50":1}}],["dh密钥协商算法握手过程",{"0":{"29":1}}],["depoly",{"2":{"4":1,"5":1}}],["解密成功后再用会话秘钥k加密一段信息发送给客户端",{"2":{"29":1}}],["解密成功后表示通信双方秘钥协商成功",{"2":{"28":1}}],["解密成功后服务器再用会话秘钥再加密一段信息并将这段信息发送给客户端",{"2":{"28":1}}],["随后通过dh算法参数以及服务器端的dh算法公钥和自己生成的私钥计算出r3",{"2":{"29":1}}],["随后通过会话秘钥k解密客户端发送的加密信息",{"2":{"28":1}}],["随后的通信内容都使用该会话秘钥进行加解密",{"2":{"28":1}}],["随后从证书中取出公钥并用此公钥加密r3",{"2":{"28":1}}],["加密套件的作用",{"0":{"31":1}}],["加密套件以及服务证书后",{"2":{"28":1}}],["加密通信",{"0":{"26":1}}],["客户端使用私钥加密随机数据后发送回服务器",{"2":{"77":1}}],["客户端发起ssh登陆请求",{"2":{"77":1}}],["客户端解密成功后",{"2":{"29":1}}],["客户端验证证书成功后使用证书公钥解密dh算法参数和dh算法公钥",{"2":{"29":1}}],["客户端此时收到服务器发来的随机数r2",{"2":{"29":1}}],["客户端收到二进制帧后通过帧上携带的流id便可知的该帧属于哪个请求对应的响应",{"2":{"38":1}}],["客户端收到加密信息后使用会话秘钥解密",{"2":{"28":1}}],["客户端收到随机数r2",{"2":{"28":1}}],["客户端首先发送一个随机数r1以及客户端所支持的加密套件到服务器",{"2":{"28":1,"29":1}}],["服务器通过客户端公钥解密客户端发回的数据",{"2":{"77":1}}],["服务器收到请求后发送随机数据到客户端",{"2":{"77":1}}],["服务器在得到客户端发来的dh算法公钥后",{"2":{"29":1}}],["服务器证书以及加密后的dh算法参数和dh算法公钥",{"2":{"29":1}}],["服务器发送证书后先生成一个私钥",{"2":{"29":1}}],["服务器接收到客户端发送的信息后先用私钥解密出r3",{"2":{"28":1}}],["服务器接到请求后生成一个随机数r2",{"2":{"28":1,"29":1}}],["服务器紧接着将自己的证书也发送给客户端",{"2":{"28":1,"29":1}}],["即口令登录",{"2":{"75":1}}],["即function对象的原型链为function",{"2":{"65":1}}],["即object",{"2":{"63":1,"65":1}}],["即允许相同域名下的请求最多可以同时建立起6个tcp连接",{"2":{"37":1}}],["即使该函数已经调用完成",{"2":{"82":1}}],["即使用户没有设置任何git",{"2":{"68":1}}],["即使有一个队列在传输过程中被阻塞掉了",{"2":{"35":1}}],["即使经过加密也难免让人怀疑其安全性",{"2":{"30":1}}],["即使遭到黑客监听黑客也无法获取通信的具体内容",{"2":{"26":1}}],["即在http的基础上再套一层ssl",{"2":{"23":1}}],["2通过引入二进制帧的方法实现了相同域名下的所用请求在同一个tcp连接上并发发送和接收从而实现了tcp利用率的最大化",{"2":{"40":1}}],["2的队头阻塞的根本原因是tcp的重传机制",{"2":{"41":1}}],["2的缺点",{"0":{"40":1}}],["2的改进",{"0":{"38":1}}],["2请求流程图",{"2":{"38":1}}],["2中最小的传输单元是一个二进制帧",{"2":{"38":1}}],["2对请求发送方式做了一些修改",{"2":{"38":1}}],["2是如何实现并发发送http请求的",{"2":{"38":1}}],["2",{"0":{"26":1,"29":1,"46":1,"48":1,"49":1,"50":2,"53":1,"58":1,"77":1},"1":{"49":1,"50":1},"2":{"37":1,"38":1,"50":1,"69":1}}],["身份认证就是我们能够确认我们当前访问的服务器就是我们要访问的服务器而不是黑客的服务器",{"2":{"25":1}}],["身份认证",{"0":{"25":1}}],["\\u00101",{"0":{"25":1}}],["+",{"2":{"23":1}}],["简而言之就是计算机之间的加密通信协议",{"2":{"73":1}}],["简而言之每发起一次http请求都会建立一次tcp连接",{"2":{"34":1}}],["简而言之https",{"2":{"23":1}}],["简单来说规范定义了promise有pending",{"2":{"18":1}}],["编译的整体过程",{"0":{"21":1}}],["编译原理",{"0":{"20":1},"1":{"21":1}}],["1通过长链接的方式提高了tcp连接的利用率",{"2":{"37":1}}],["1的缺点",{"0":{"37":1}}],["1的改进",{"0":{"35":1}}],["1到2",{"0":{"36":1},"1":{"37":1,"38":1}}],["1在复用tcp连接时由于串行发送的请求中某一请求迟迟无法响应从而造成整个请求队列被阻塞的问题",{"2":{"35":1}}],["1中通过同一域名下的请求复用tcp连接的方式提高了tcp连接的利用率降低了用户的等待时间",{"2":{"35":1}}],["1默认开启的长链接模式能够复用之前创建好的tcp连接",{"2":{"35":1}}],["1长链接下发送多个请求",{"2":{"35":1}}],["1版本中在同一个tcp连接中传输的请求是串行发送的",{"2":{"38":1}}],["1版本增加了长链接功能",{"2":{"35":1}}],["1版本被推了出来",{"2":{"35":1}}],["1",{"0":{"21":1,"28":1,"33":1,"34":1,"35":1,"37":1,"44":1,"45":2,"46":1,"47":1,"49":1,"52":1,"57":1,"76":1},"1":{"34":1,"35":1,"45":1,"46":1,"47":1},"2":{"34":2,"35":7,"37":1,"38":1,"50":1}}],["写此文章作为总结",{"2":{"20":1}}],["test这个命令",{"2":{"70":1}}],["test命令",{"2":{"67":1}}],["test",{"2":{"67":1,"70":2}}],["true",{"2":{"52":1}}],["try",{"2":{"17":1,"18":3}}],["typeof的返回值和javascript类型并不是一一对应的关系",{"2":{"47":1}}],["typeof返回的所有结果入下图所示",{"2":{"46":1}}],["typeof",{"2":{"46":1,"49":1,"50":4}}],["then函数是promise中最重要的函数之一",{"2":{"19":1}}],["then函数",{"0":{"19":1}}],["this",{"2":{"17":4,"18":11,"79":7,"80":11}}],["tom",{"2":{"63":3,"65":1,"66":2}}],["tostring都可以但是array",{"2":{"59":1}}],["tostring方法",{"0":{"58":1},"2":{"50":1,"56":1}}],["tostring方法进行判断",{"2":{"50":1}}],["tostring是因为有些对象的原型可能重写了tostring方法",{"2":{"50":1}}],["tostring",{"2":{"50":2,"58":1,"59":1}}],["tostring进行判断",{"0":{"50":1}}],["to",{"2":{"4":1,"11":1}}],["\\tobject",{"2":{"54":1}}],["\\tthis",{"2":{"17":1}}],["\\tstate",{"2":{"17":1}}],["==",{"2":{"49":1,"79":1,"80":1}}],["===",{"2":{"18":2,"49":1,"50":1,"53":1,"54":3,"55":1,"58":1,"59":1,"63":2,"65":1}}],["=>",{"2":{"17":2,"18":2,"49":1,"50":1,"53":1,"54":2,"55":1,"57":1,"58":1,"79":6,"80":6}}],["=",{"2":{"17":8,"18":12,"23":1,"49":1,"50":1,"53":1,"54":2,"55":1,"57":1,"58":1,"63":1,"64":1,"65":1,"66":1,"79":8,"80":13}}],["其他方面的改进我会在以后的学习过程中慢慢添加进来",{"2":{"42":1}}],["其实不然",{"2":{"31":1}}],["其实用户是在和黑客进行通信",{"2":{"25":1}}],["其中rsa秘钥协商和dh秘钥协商是最常用的秘钥协商算法",{"2":{"27":1}}],["其中resolve函数能够将pendding状态转变为fulfilled状态",{"2":{"17":1}}],["其中当promise处于pending状态时",{"2":{"18":1}}],["其次是在resolve和reject函数中首先判断mypromise实例是否是pending状态",{"2":{"18":1}}],["其次之所以resolve和reject函数被声明为实例属性并且采用箭头函数是为了将这两个函数的this指向绑定为该promise实例",{"2":{"17":1}}],["其次promise的构造函数需要接收一个被称为exector的函数作为参数",{"2":{"17":1}}],["其次每个promise实例都有两个能够改变promise实例状态的函数resolve和reject",{"2":{"17":1}}],["modules目录中的commitlint包",{"2":{"71":1}}],["msg脚本内容如下",{"2":{"71":1}}],["msg这个git",{"2":{"71":1}}],["msg",{"2":{"67":1,"71":4}}],["mypromise",{"2":{"16":1,"17":1,"18":1}}],["man",{"2":{"63":4,"65":4,"66":3}}],["manyuanrong",{"2":{"4":1,"11":1}}],["master",{"2":{"4":2,"6":1,"11":1}}],["本文就以旧版http有哪些缺陷以及新版http是如何解决的为线索来讲述为什么http会从1到3",{"2":{"32":1}}],["本篇文章只是根据promises",{"2":{"16":1}}],["本篇文章记录了一下实现promise的过程",{"2":{"16":1}}],["本博客系统选择使用github",{"2":{"4":1}}],["看过规范之后觉得可以自己实现一个promise类",{"2":{"16":1}}],["手写一个promise",{"0":{"16":1},"1":{"17":1,"18":1,"19":1}}],["当此作用域运行结束变量也随之被销毁",{"2":{"82":1}}],["当目标对象发生变化时会通知所有订阅了该目标对象的观察者",{"2":{"79":1}}],["当然因为udp是不可靠的传输协议因此如何发现报文丢失以及如何进行重传的机制需要http",{"2":{"41":1}}],["当然代码写完之后是可以100",{"2":{"16":1}}],["当所用帧都被接收后客户端便把帧组装成完整的响应",{"2":{"38":1}}],["当请求的所有帧都接收完毕后会被服务器重新组装成完整的http请求",{"2":{"38":1}}],["当服务器收到二进制帧后",{"2":{"38":1}}],["当我们的javascript代码运行的时候首先会创建一个全局作用域",{"2":{"82":1}}],["当我们发起http请求时",{"2":{"38":1}}],["当我们调用setstate方法时",{"2":{"15":1}}],["当使用https协议时",{"2":{"25":1}}],["当使用http协议时",{"2":{"25":1}}],["当promise处于rejected状态时",{"2":{"18":1}}],["当promise处于fulfilled状态时",{"2":{"18":1}}],["当时之所以选择hexo主要是因为hexo是采用node",{"2":{"3":1}}],["为了解决观察者模式中由于目标对象职责过多而造成的目标对象与观察者对象耦合度较高的问题",{"2":{"80":1}}],["为了解决http",{"2":{"35":1}}],["为了能够让用户设置任何类型的git",{"2":{"68":1}}],["为了实现并发发送http请求",{"2":{"38":1}}],["为了将tcp连接的利用率达到最大化即同一域名下的请求全部通过一个tcp连接发送",{"2":{"37":1}}],["为什么",{"0":{"15":1}}],["为组件库的每一个组件或者功能进行单元测试是十分有必要的",{"2":{"1":1}}],["先说结论",{"2":{"14":1}}],["结论",{"0":{"14":1}}],["我觉我有必要学习一下",{"2":{"13":1}}],["我好像没有被问到过",{"2":{"13":1}}],["我们的防抖和节流函数就是通过闭包实现的",{"2":{"83":1}}],["我们的mypromise类做如下更改",{"2":{"18":1}}],["我们可以在子作用域中访问到这个变量",{"2":{"82":1}}],["我们可以使用object",{"2":{"50":1}}],["我们单独抽取出来形成一个事件总线",{"2":{"80":1}}],["我们现在称之为订阅者",{"2":{"80":1}}],["我们现在称其为发布者",{"2":{"80":1}}],["我们已经知道了对象tom的原型为man",{"2":{"65":1}}],["我们还以以上代码进行分析",{"2":{"65":1}}],["我们还可设置name属性用于在github页面上进行显示",{"2":{"8":1}}],["我们之前已经讲解了如何使用typeof进行判断变量是否为对象",{"2":{"50":1}}],["我们知道tom对象的",{"2":{"63":1}}],["我们知道typeof",{"2":{"49":1}}],["我们知道继承是对象语言的特性之一",{"2":{"61":1}}],["我们知道http",{"2":{"37":1}}],["我们知道http是建立在tcp之上的应用层协议",{"2":{"34":1}}],["我们知道每个promise实例可能是pendding",{"2":{"17":1}}],["我们首先搭建一个promise的框架然后根据promises",{"2":{"17":1}}],["我们首先使用actions",{"2":{"11":1}}],["我们只需要将我们的ci",{"2":{"4":1}}],["未完成待续",{"0":{"12":1}}],["再接着使用manyuanrong",{"2":{"11":1}}],["多个job之间默认是相互独立了",{"2":{"7":1}}],["而这个访问函数就是闭包函数",{"2":{"82":1}}],["而是采用了原型链的实现方式",{"2":{"61":1}}],["而是将tcp连接保留一段时间",{"2":{"35":1}}],["而不是obj",{"2":{"50":1}}],["而不是由各种javascript内置构造函数生成的对象时使用typeof方法就会显得捉襟见肘",{"2":{"50":1}}],["而且所有的脚本都保存在了一个地方",{"2":{"69":1}}],["而且像数组",{"2":{"50":1}}],["而且这个value不能再改变",{"2":{"18":1}}],["而在http",{"2":{"38":1}}],["而在branches中我们可以更精确的指明我们是需要在向哪几个分支推送的时候触发此workflow",{"2":{"6":1}}],["而r1",{"2":{"30":1}}],["而之前的gitlab",{"2":{"3":1}}],["如图所示",{"2":{"80":1}}],["如同使用for",{"2":{"53":1}}],["如上图所示",{"2":{"25":1,"45":1}}],["如上面的yml配置所示",{"2":{"6":1}}],["如果操作不当可能会导致内存泄漏的发生",{"2":{"84":1}}],["如果跟原始数据一致则允许登陆",{"2":{"77":1}}],["如果想要解决就不得不另辟蹊径采用一种新的工作模型",{"2":{"68":1}}],["如果没有就继续往下执行",{"2":{"68":1}}],["如果有就运行用户配置的命令",{"2":{"68":1}}],["如果原型对象上也没有此属性",{"2":{"61":1}}],["如果该对象没有此属性",{"2":{"61":1}}],["如果该对象上没有这个属性",{"2":{"61":1}}],["如果还是没有",{"2":{"61":1}}],["如果结果为空那么就是一个空对象",{"2":{"53":1}}],["如果我们在子作用域之后访问该变量也是找不到的",{"2":{"82":1}}],["如果我们在子作用域创建之前访问子作用域中的变量肯定是找不到的",{"2":{"82":1}}],["如果我们在一个函数中再声明一个函数那么就会创建一个子作用域的子作用域",{"2":{"82":1}}],["如果我们使用isobject函数对变量进行判断时不仅",{"2":{"50":1}}],["如果我们能在一个tcp连接中并行的发送所有请求",{"2":{"38":1}}],["如果不是再用typeof",{"2":{"49":1}}],["如果当前发送的请求因为各种原因迟迟没有收到响应那么在队列中的其他请求也必须进行等待",{"2":{"35":1}}],["如果需要n次http请求就会建立起n次tcp连接",{"2":{"34":1}}],["如果遭到黑客的监听那么通信内容一览无余",{"2":{"26":1}}],["如果exector函数执行出错",{"2":{"17":1}}],["如果为true",{"2":{"15":1}}],["如果isbatchingupdates为false则setstate进行同步更新",{"2":{"15":1}}],["如果你想要多个job按照一定顺序执行的话就要设定他们之间的依赖关系",{"2":{"7":1}}],["如",{"2":{"8":1}}],["如下所示",{"2":{"7":1}}],["如下图所示",{"2":{"5":1,"34":1,"35":1}}],["如何判断一个变量是否是数组",{"0":{"56":1},"1":{"57":1,"58":1,"59":1}}],["如何判断一个变量是否为对象",{"0":{"48":1},"1":{"49":1,"50":1}}],["如何判断一个对象是否为空对象",{"0":{"51":1},"1":{"52":1,"53":1,"54":1,"55":1}}],["如何使用github",{"0":{"4":1},"1":{"5":1,"6":1,"7":1,"8":1,"9":1,"10":1,"11":1}}],["如何搭建自己的博客",{"0":{"2":1},"1":{"3":1,"4":1,"5":1,"6":1,"7":1,"8":1,"9":1,"10":1,"11":1,"12":1}}],["在一个函数中定义一个变该函数作用域中变量的访问函数",{"2":{"82":1}}],["在代码中也常常使用",{"2":{"81":1}}],["在发布订阅模式中",{"2":{"80":1}}],["在观察者模式下",{"2":{"79":1}}],["在使用ssh远程登录服务器的过程觉ssh似乎在很多地方都有提到比如github",{"2":{"72":1}}],["在使用htpps通信过程中需通信双方先进行https握手",{"2":{"27":1}}],["在新版husky中我们的commit",{"2":{"71":1}}],["在新版husky中$husky",{"2":{"71":1}}],["在以前的我们通常是这样配置",{"2":{"71":1}}],["在项目中我们会使用commit",{"2":{"71":1}}],["在packgae",{"2":{"70":1}}],["在package",{"2":{"67":1}}],["在这个脚本中husky会检查用户是否配置该hook",{"2":{"68":1}}],["在这个shell中我们先执行了npm",{"2":{"11":1}}],["在这个steps中",{"2":{"11":1}}],["在之前的项目中我们通常都是这样完成对husky的引入和设置的",{"2":{"67":1}}],["在之前的http中最小的传输单元便是一个http请求报文",{"2":{"38":1}}],["在commit之前先执行npm",{"2":{"67":1}}],["在做前端工程化时husky可以说是一个必不可少的工具",{"2":{"67":1}}],["在es6之前javascript中只有函数作用域",{"2":{"82":1}}],["在es6中为了让javascript与主流的语言更接近推出了新的class语法用于对象编程",{"2":{"66":1}}],["在ecmascript",{"2":{"62":1}}],["在上述代码中我们首先声明了一个函数man",{"2":{"63":1}}],["在上述握手过程中我多次提到加密套件",{"2":{"31":1}}],["在下面的讲述中我们将使用ecmascript",{"2":{"62":1}}],["在javascript的模块功能还没有被标准化的时候",{"2":{"83":1}}],["在javascript中我们说的闭包其实说的是闭包函数",{"2":{"81":1}}],["在javascript中闭包是一个很常见的概念",{"2":{"81":1}}],["在javascript中",{"2":{"65":1}}],["在javascript中函数对象也有构造函数",{"2":{"65":1}}],["在javascript中一切皆对象",{"2":{"65":1}}],["在javascript中如果在函数调用前使用new关键字那么该函数就变成了构造函数",{"2":{"63":1}}],["在javascript中访问一个对象的属性",{"2":{"61":1}}],["在javascript中有两个重要且基础的链",{"2":{"60":1}}],["在java与c++中是基于类实现的继承",{"2":{"61":1}}],["在我们的javascript项目中我们还经常需要判断一个变量是否为空对象",{"2":{"51":1}}],["在工作中难免会遇到判断一个变量是否是对象",{"2":{"43":1}}],["在早期这种做法无可厚非",{"2":{"34":1}}],["在http",{"2":{"34":1}}],["在rsa秘钥协商中我们使用公钥加密r3来保证r3不会被第三方获取",{"2":{"30":1}}],["在resolve和reject函数中我们使用try",{"2":{"18":1}}],["在构造函数中我们用try",{"2":{"17":1}}],["在steps中我们可以运行actions或者命令",{"2":{"11":1}}],["在build",{"2":{"9":1}}],["在github",{"2":{"7":1}}],["在",{"2":{"5":1}}],["eventname",{"2":{"80":13}}],["eventbus",{"2":{"80":13}}],["ele",{"2":{"79":2,"80":2}}],["else",{"2":{"59":1,"80":1}}],["edit",{"2":{"71":3}}],["es6中的继承与原型链",{"0":{"66":1}}],["e",{"2":{"17":2,"18":6,"67":1,"71":1}}],["extends",{"2":{"66":1}}],["exector",{"2":{"17":2,"18":2}}],["example",{"2":{"4":1,"11":1,"64":1}}],["endpoint",{"2":{"4":1,"11":1}}],["environment表示我们所运行的环境",{"2":{"10":1}}],["environment",{"0":{"10":1},"2":{"4":1}}],["$1",{"2":{"71":3}}],["$0",{"2":{"70":1,"71":1}}],["$husky",{"2":{"67":1,"71":1}}],["$",{"2":{"4":2,"11":2,"70":1,"71":1}}],["i",{"2":{"52":1}}],["isarray是es6的语法我们可以将这两个方法封装起来",{"2":{"59":1}}],["isarray与object",{"2":{"59":1}}],["isarray",{"2":{"57":2,"58":1,"59":3}}],["isarray方法是es6新增的专门判断一个对象是不是数组的方法",{"2":{"57":1}}],["isarray方法",{"0":{"57":1},"2":{"56":1}}],["isemptyobj",{"2":{"52":1,"53":1,"54":2,"55":1}}],["isplainobject",{"2":{"50":1}}],["if",{"2":{"18":2,"59":1,"80":2}}],["in循环进行判断一样",{"2":{"53":1}}],["in来遍历一个对象",{"2":{"52":1}}],["in",{"0":{"52":1},"2":{"52":3}}],["intall",{"2":{"11":1}}],["install命令",{"2":{"70":1}}],["install安装完项目依赖后会执行",{"2":{"70":1}}],["install将git",{"2":{"69":1}}],["install",{"2":{"4":1,"11":1,"67":1,"70":3,"71":4}}],["id",{"2":{"4":2,"11":2}}],["add",{"2":{"70":1,"71":2}}],["add命令向",{"2":{"69":1}}],["array",{"2":{"57":2,"58":1,"59":3}}],["a",{"2":{"50":6}}],["a+测试的mypromise类",{"2":{"17":1}}],["a+测试的",{"2":{"16":1}}],["a+规范对then函数的定义",{"2":{"19":1}}],["a+规范定义的promise的状态",{"2":{"18":1}}],["a+规范一步一步向骨架中添加代码",{"2":{"17":1}}],["a+规范实现一个我们自己的promise类",{"2":{"16":1}}],["a+规范的要求进行实现并没有做太多的代码优化",{"2":{"16":1}}],["a+规范",{"2":{"16":1}}],["asscess",{"2":{"4":2,"11":2}}],["alive",{"2":{"35":1}}],["ali",{"2":{"4":3,"11":3}}],["aliyuncs",{"2":{"4":1,"11":1}}],["access",{"2":{"4":2,"11":2}}],["actons使用起来非常简单",{"2":{"4":1}}],["actions的概念中一个workflow可以有一个和多个job",{"2":{"7":1}}],["actions配置文件",{"2":{"4":1}}],["actions作为ci",{"2":{"4":1}}],["actions将自己的博客打包发布到阿里oss",{"0":{"4":1},"1":{"5":1,"6":1,"7":1,"8":1,"9":1,"10":1,"11":1}}],["actions+阿里oss",{"2":{"3":1}}],["actions是免费的",{"2":{"3":1}}],["actions",{"2":{"2":1,"3":1,"4":2,"11":2}}],["hostname",{"2":{"76":2}}],["hook所要执行的脚本",{"2":{"71":1}}],["hook所要执行的真正命令",{"2":{"68":1}}],["hook我们可以使用以下命令来创建git",{"2":{"71":1}}],["hook来校验我们commit时添加的备注信息是否符合规范",{"2":{"71":1}}],["hook就要保证在这两个地方同步执行对应的操作",{"2":{"68":1}}],["hook功能",{"2":{"68":1}}],["hook呢",{"2":{"68":1}}],["hook",{"2":{"68":4,"69":1}}],["hooks所在的目录",{"2":{"70":1}}],["hooks所在的目录而不是使用默认的",{"2":{"69":1}}],["hooks的目录指定为",{"2":{"69":1}}],["hookspath可以让你指定git",{"2":{"69":1}}],["hookspath",{"2":{"69":1}}],["hooks都能正常工作",{"2":{"68":1}}],["hooks",{"2":{"67":3,"68":2,"69":1,"70":2,"71":1}}],["husk",{"2":{"71":1}}],["husky也向git中添加了所有类型的git",{"2":{"68":1}}],["husky都能确保其正常运行",{"2":{"68":1}}],["husky不得不创建所有类型的git",{"2":{"68":1}}],["husky为什么放弃了之前的配置方式",{"0":{"68":1}}],["husky",{"2":{"67":2,"69":3,"70":8,"71":5}}],["husky可以让我们向项目中方便添加git",{"2":{"67":1}}],["husky使用总结",{"0":{"67":1},"1":{"68":1,"69":1,"70":1,"71":1}}],["human",{"2":{"66":4}}],["http从2到3",{"0":{"39":1},"1":{"40":1,"41":1}}],["http从1",{"0":{"33":1,"36":1},"1":{"34":1,"35":1,"37":1,"38":1}}],["http从1到3",{"0":{"32":1},"1":{"33":1,"34":1,"35":1,"36":1,"37":1,"38":1,"39":1,"40":1,"41":1,"42":1}}],["http1",{"2":{"35":1}}],["http协议的通行双方使用的是明文进行通行",{"2":{"26":1}}],["http",{"0":{"34":1,"35":1,"37":1,"38":1,"40":1,"41":1},"2":{"23":1,"34":1,"35":4,"38":3,"40":1}}],["https握手的目的有两个身份认证以及秘钥协商",{"2":{"27":1}}],["https握手过程",{"0":{"27":1},"1":{"28":1,"29":1,"30":1,"31":1}}],["https的通信双方使用密文进行通信",{"2":{"26":1}}],["https的作用",{"0":{"24":1},"1":{"25":1,"26":1}}],["https就是安全的http",{"2":{"23":1}}],["https是什么",{"0":{"23":1},"1":{"24":1,"25":1,"26":1}}],["https是可以说是web应用的基础协议",{"2":{"22":1}}],["https学习小结",{"0":{"22":1},"1":{"23":1,"24":1,"25":1,"26":1,"27":1,"28":1,"29":1,"30":1,"31":1}}],["hangzhou",{"2":{"4":1,"11":1}}],["hexo",{"2":{"4":1,"11":1}}],["0发送多个请求",{"2":{"35":1}}],["0的请求过程",{"2":{"34":1}}],["0的版本中客户端每发起一次http请求都要先建立一个tcp连接",{"2":{"34":1}}],["0的缺点",{"0":{"34":1}}],["0到1",{"0":{"33":1},"1":{"34":1,"35":1}}],["0这个action下载和配置ali对象存储",{"2":{"11":1}}],["0",{"2":{"4":1,"11":1,"35":1,"53":1,"54":3,"55":1,"67":2}}],["o3",{"2":{"79":3}}],["o2",{"2":{"79":3}}],["o1",{"2":{"79":3}}],["observer",{"2":{"79":9}}],["observers",{"2":{"79":6}}],["obj",{"2":{"49":3,"50":2,"52":2,"53":2,"54":6,"55":2,"57":2,"58":2,"59":3}}],["object",{"2":{"49":2,"50":7,"53":3,"54":2,"58":2,"59":2,"64":1,"65":4,"66":2}}],["ownkeys",{"2":{"55":1}}],["ownkeys也可以返回对象自身属性名所构成的数组",{"2":{"55":1}}],["ownkeys方法判断",{"0":{"55":1}}],["oss",{"2":{"4":5,"11":5}}],["ossutil",{"2":{"4":3,"11":4}}],["on为ubuntu",{"2":{"9":1}}],["on选项用于设置我们job在什么环境下运行",{"2":{"9":1}}],["on字段用于设置该workflow的执行时机",{"2":{"6":1}}],["on字段如下所示",{"2":{"6":1}}],["on字段",{"0":{"6":1}}],["on",{"0":{"9":1},"2":{"4":2}}],["|",{"2":{"4":1,"11":1}}],["notify",{"2":{"79":3,"80":2}}],["no",{"2":{"71":4}}],["node",{"2":{"4":2,"11":3}}],["npx",{"2":{"70":1,"71":4}}],["npm",{"2":{"4":3,"11":3,"67":2,"70":3}}],["new",{"2":{"50":1,"63":1,"65":1,"66":1,"79":4,"80":7}}],["needs",{"2":{"7":2}}],["null",{"2":{"18":2,"49":1,"65":3,"66":2}}],["name字段不是特别重要",{"2":{"5":1}}],["name字段",{"0":{"5":1}}],["name",{"2":{"4":3,"8":1,"11":3}}],["listeners",{"2":{"80":8}}],["length",{"2":{"53":1,"54":3,"55":1}}],["let",{"2":{"52":1}}],["log",{"2":{"50":4,"79":3,"80":3}}],["lts",{"2":{"4":1,"11":2}}],["latest",{"2":{"4":1,"9":1}}],["rsa秘钥协商算法和dh秘钥协商算法的区别",{"0":{"30":1}}],["rsa秘钥协商算法握手过程",{"0":{"28":1}}],["r3计算出的",{"2":{"30":1}}],["r3计算出会话秘钥k",{"2":{"28":1,"29":1}}],["r3计算出会话秘钥k并用此会话秘钥加密一段信息",{"2":{"28":1}}],["r3算出会话秘钥k",{"2":{"29":1}}],["r2是明文传输",{"2":{"30":1}}],["r2",{"2":{"28":2,"29":2,"30":1}}],["return",{"2":{"52":2,"59":2,"79":1,"80":1}}],["reason",{"2":{"18":4}}],["react会根据isbatchingupdates这个变量来决定setstate的行为",{"2":{"15":1}}],["resolve",{"2":{"17":2,"18":2,"50":1}}],["reject",{"2":{"17":3,"18":5}}],["rejected三种状态",{"2":{"18":1}}],["rejected",{"2":{"17":3,"18":3}}],["rejected状态之一",{"2":{"17":1}}],["reject函数能够将pending状态转变为rejected状态",{"2":{"17":1}}],["reflect",{"2":{"55":1}}],["ref",{"2":{"4":1,"11":1}}],["rf",{"2":{"4":1,"11":1}}],["runs",{"0":{"9":1},"2":{"4":1,"9":1}}],["run",{"2":{"4":5,"11":6,"67":2,"70":3}}],["with",{"2":{"4":3,"11":3}}],["workflows目录下的每个",{"2":{"5":1}}],["workflows目录下",{"2":{"4":1}}],["var",{"2":{"63":1,"65":1,"66":1}}],["value",{"2":{"18":4}}],["v2",{"2":{"4":1,"11":2}}],["version",{"2":{"4":1,"11":1}}],["v3这个action安装指定版本的node",{"2":{"11":1}}],["v3这个action将项目分支切换到master",{"2":{"11":1}}],["v3",{"2":{"4":2,"11":2}}],["vue组件库的单元测试",{"0":{"1":1}}],["update",{"2":{"79":2,"80":2}}],["unsubscribe",{"2":{"79":2,"80":3}}],["user",{"2":{"76":2}}],["uses",{"2":{"4":3,"11":3}}],["ubuntu",{"2":{"4":1}}],["sub",{"2":{"79":5}}],["subscribe3",{"2":{"80":2}}],["subscribe2",{"2":{"80":2}}],["subscribe1",{"2":{"80":2}}],["subscriber",{"2":{"80":11}}],["subscribe",{"2":{"79":7,"80":6}}],["subject",{"2":{"79":4}}],["ssh主要有三种ssh身份验证方式",{"2":{"75":1}}],["ssh不仅能实现加密通信",{"2":{"75":1}}],["ssh身份验证",{"0":{"75":1},"1":{"76":1,"77":1}}],["ssh如何实现加密通信呢",{"2":{"74":1}}],["ssh加密通信原理",{"0":{"74":1}}],["ssh",{"2":{"73":1,"76":1}}],["ssh是什么",{"0":{"73":1}}],["ssl",{"2":{"23":1}}],["sh",{"2":{"70":2,"71":2}}],["shell$",{"2":{"76":1}}],["shell",{"2":{"70":1,"71":1,"73":1}}],["scripts",{"2":{"70":1}}],["state",{"2":{"17":2,"18":5}}],["steps表示一系列顺序执行的任务",{"2":{"11":1}}],["steps是job运行的关键配置",{"2":{"11":1}}],["steps",{"0":{"11":1},"2":{"4":1}}],["secure",{"2":{"73":1}}],["secret",{"2":{"4":2,"11":2,"28":1,"29":1}}],["secrets",{"2":{"4":2,"11":2}}],["setprototypeof这两个方法分别用于访问和修改对象的",{"2":{"62":1}}],["setinterval以及dom原生事件中表现问同步更新",{"2":{"14":1}}],["setstate不会立即执行更新而是将更新加入队列中等待以后进行批量更新",{"2":{"15":1}}],["setstate在react组件的生命周期以及合成时间中表现为异步更新",{"2":{"14":1}}],["setstate是异步更新还是同步更新据说是react面试中最常问的问题了",{"2":{"13":1}}],["setstate是异步更新还是同步更新",{"0":{"13":1},"1":{"14":1,"15":1}}],["set",{"2":{"4":1,"11":1}}],["setup",{"2":{"4":2,"11":4}}],["seo实战",{"0":{"0":1}}],["params这个变量不再使用了",{"2":{"71":1}}],["params",{"2":{"67":1,"71":1}}],["prepare脚本会在npm",{"2":{"70":1}}],["prepare",{"2":{"70":1}}],["pre",{"2":{"67":1,"70":2}}],["premaster",{"2":{"28":1,"29":1}}],["proto",{"0":{"62":1},"2":{"52":1,"62":1}}],["prototype对象作为一个普通对象",{"2":{"65":1}}],["prototype对象是一切对象的根对象",{"2":{"64":1}}],["prototype的原型为object",{"2":{"65":1}}],["prototype的原型链为man",{"2":{"65":1}}],["prototype的原型是object",{"2":{"65":1}}],["prototype的原型是什么呢",{"2":{"65":1}}],["prototype作为一个对象",{"2":{"65":1}}],["prototype也是一个对象",{"2":{"64":1}}],["prototype",{"0":{"19":1,"50":1,"58":1,"62":1},"2":{"19":1,"50":4,"56":1,"58":1,"59":2,"62":2,"63":2,"64":1,"65":13,"66":5}}],["promise",{"0":{"19":1},"2":{"19":1,"50":2}}],["promise也不能再转变为其他状态",{"2":{"18":1}}],["promise不能再转变为其他状态",{"2":{"18":1}}],["promise可以转变fulfilled或者rejected状态",{"2":{"18":1}}],["promise的状态",{"0":{"18":1}}],["promise骨架",{"0":{"17":1}}],["production",{"2":{"4":1}}],["pending",{"2":{"17":3,"18":5}}],["publish3",{"2":{"80":2}}],["publish2",{"2":{"80":2}}],["publish1",{"2":{"80":2}}],["publish",{"2":{"80":4}}],["publisher",{"2":{"80":5}}],["public",{"2":{"4":1,"11":1}}],["push表示我们需要在向github中推送代码后执行该workflow",{"2":{"6":1}}],["push",{"2":{"4":1,"6":1,"79":1,"80":1}}],["json中添加prepare脚本",{"2":{"70":1}}],["json中配置git",{"2":{"68":1}}],["json中设置我们需要的git",{"2":{"67":1}}],["json",{"2":{"67":1,"70":1,"71":1}}],["js进行编写的",{"2":{"3":1}}],["javascript的模块第三方标准就是通过闭包实现的",{"2":{"83":1}}],["javascript的变量类型",{"0":{"45":1}}],["javascriptclass",{"2":{"66":1,"79":1,"80":1}}],["javascriptconsole",{"2":{"50":1}}],["javascriptconst",{"2":{"17":1,"18":1,"50":1,"53":1,"54":2,"55":1,"57":1,"58":1}}],["javascriptvar",{"2":{"64":1}}],["javascript对象的",{"2":{"62":1}}],["javascript则不同",{"2":{"61":1}}],["javascript原型链总结",{"0":{"60":1},"1":{"61":1,"62":1,"63":1,"64":1,"65":1,"66":1}}],["javascriptfunction",{"2":{"52":1,"59":1,"63":1,"65":1}}],["javascriptisobject",{"2":{"49":1}}],["javascript类型和typeof的对应关系如下图所示",{"2":{"47":1}}],["javascript类型和typeof的对应关系",{"0":{"47":1}}],["javascript中如何判断一个变量是否是对象",{"0":{"43":1},"1":{"44":1,"45":1,"46":1,"47":1,"48":1,"49":1,"50":1,"51":1,"52":1,"53":1,"54":1,"55":1,"56":1,"57":1,"58":1,"59":1}}],["job中runs",{"2":{"9":1}}],["job的id",{"0":{"8":1}}],["job3需要等job1和job2都执行成功后才能执行",{"2":{"7":1}}],["job3",{"2":{"7":2}}],["job2需要等job1执行成功后才能执行",{"2":{"7":1}}],["job2",{"2":{"7":3}}],["job1",{"2":{"7":4}}],["jobs字段",{"0":{"7":1},"1":{"8":1,"9":1,"10":1,"11":1}}],["jobs",{"2":{"4":1}}],["ymlsteps",{"2":{"11":1}}],["ymljobs",{"2":{"7":1,"8":1}}],["ymlon",{"2":{"6":1}}],["yml文件都是一个workflow",{"2":{"5":1}}],["yml文件放到",{"2":{"4":1}}],["ymlname",{"2":{"4":1,"5":1}}],["后面我会逐行解释",{"2":{"4":1}}],["以及闭包函数的原理",{"2":{"83":1}}],["以此类推直到全局作用域",{"2":{"82":1}}],["以此类推直到找到为止",{"2":{"61":1}}],["以此类推",{"2":{"61":1}}],["以上便是promise",{"2":{"19":1}}],["以下就是这个博客的github",{"2":{"4":1}}],["以前遇到的坑也还要重新再踩一遍",{"2":{"2":1}}],["话说回来",{"2":{"4":1}}],["思想的一种体现",{"2":{"4":1}}],["持续部署",{"2":{"4":1}}],["持续集成",{"2":{"4":1}}],["然后在该函数中将此访问函数返回",{"2":{"82":1}}],["然后在当前作用域的父作用域查找变量是否存在",{"2":{"82":1}}],["然后每声明一个函数就会创建一个子作用域",{"2":{"82":1}}],["然后又声明了一个继承自human类的man类",{"2":{"66":1}}],["然后客户端将一个个二进制帧通过tcp连接发送到服务器上",{"2":{"38":1}}],["然后将这些二进制数据切片成一个个二进制帧",{"2":{"38":1}}],["然后将这些静态资源手动拷贝阿里oss上",{"2":{"4":1}}],["然后才是发送http请求",{"2":{"34":1}}],["然后通过r1",{"2":{"28":1,"29":1}}],["然后通过https",{"2":{"3":1}}],["然后根据客户端所发来的加密套件选择其中一个",{"2":{"28":1,"29":1}}],["然后使用该秘钥加密和解密双方之间的通信内容",{"2":{"74":1}}],["然后使用husky",{"2":{"69":1}}],["然后使用dh算法参数以及自己生成私钥计算出一个公钥",{"2":{"29":1}}],["然后使用私钥和dh算法参数生成一个公钥",{"2":{"29":1}}],["然后使用r1",{"2":{"28":1,"29":1}}],["然后使用npm",{"2":{"11":1}}],["然后使用actions",{"2":{"11":1}}],["bin",{"2":{"70":1,"71":1}}],["b",{"2":{"50":6}}],["build执行构建",{"2":{"11":1}}],["build就是该job的唯一id",{"2":{"8":1}}],["build",{"2":{"4":3,"8":1,"11":2}}],["build命令在本机将我们写的博客打包成静态资源文件",{"2":{"4":1}}],["branches",{"2":{"4":1,"6":1}}],["blog",{"2":{"3":1,"4":2,"5":1,"11":1}}],["刚开始使用hexo时我们通常都是选择在本地写完博客后使用npm",{"2":{"4":1}}],["getprototypeof",{"2":{"63":2,"65":1}}],["getprototypeof和object",{"2":{"62":1}}],["getownpropertysymbols",{"2":{"54":2}}],["getownpropertynames",{"2":{"54":2}}],["getownpropertynames方法判断",{"0":{"54":1}}],["gt",{"2":{"7":2,"65":8,"66":8}}],["gallium",{"2":{"4":1,"11":2}}],["git",{"2":{"67":1,"68":1,"69":1,"71":2}}],["github就能读取我们的配置文件进行一系列的操作自动部署我们的博客了",{"2":{"4":1}}],["github",{"2":{"4":2,"5":1}}],["gitlab以docker的方式运行在阿里云上",{"2":{"2":1}}],["glimmertreasure",{"2":{"3":1}}],["最终形成一个能够通过promises",{"2":{"17":1}}],["最终打包后的文件被存储在了阿里oss上",{"2":{"3":1}}],["最近买了台阿里云服务器想要空闲的时候搞点事情",{"2":{"72":1}}],["最近想回顾一下http方面的知识",{"2":{"32":1}}],["最近在学习编译原理",{"2":{"20":1}}],["最近阅读了promises",{"2":{"16":1}}],["最近负责公司vue组件库的开发与维护工作",{"2":{"1":1}}],["最后再创造了一个man类的实例对象tom",{"2":{"66":1}}],["最后当客户端收到服务器发送的响应后就会关闭tcp连接",{"2":{"34":1}}],["最后客户端将自己的dh算法公钥以及通过会话秘钥加密的信息发送给服务器",{"2":{"29":1}}],["最后客户端将加密后的r3以及经过会话秘钥加密后的信息一同发送给服务器",{"2":{"28":1}}],["最后使用证书私钥加密dh算法参数和dh算法公钥",{"2":{"29":1}}],["最后使用npm",{"2":{"11":1}}],["最后将选择好的加密套件连同随机数r2一同发给客户端",{"2":{"28":1,"29":1}}],["最后将我们构建后的文件复制到ali对象存储中",{"2":{"11":1}}],["博客的打包和部署从gitlab",{"2":{"3":1}}],["博客还是采用hexo进行构建",{"2":{"3":1}}],["技术栈介绍",{"0":{"3":1}}],["方便以后查看",{"2":{"2":1}}],["重新查找资料和踩坑的过程自不必说十分浪费时间",{"2":{"2":1}}],["替换成github",{"2":{"2":1}}],["chuan大佬的帮助",{"2":{"71":1}}],["checkout",{"2":{"4":1,"11":2}}],["call",{"2":{"50":1,"58":1,"59":1}}],["catch包围代码",{"2":{"18":1}}],["catch包围exector函数的执行",{"2":{"17":1}}],["catch",{"2":{"17":1,"18":3}}],["click1",{"2":{"80":6}}],["class",{"2":{"17":1,"18":1,"66":1,"79":1,"80":2}}],["clean清楚npm的缓存",{"2":{"11":1}}],["clean",{"2":{"4":1,"11":1}}],["cp",{"2":{"4":1,"11":1}}],["core",{"2":{"69":1}}],["console",{"2":{"50":3,"79":3,"80":3}}],["constructor",{"2":{"17":1,"18":1,"63":1,"79":1,"80":1}}],["const",{"2":{"17":2,"18":2,"79":5,"80":8}}],["connection",{"2":{"35":1}}],["copy",{"2":{"4":1,"11":1}}],["commit脚本内容如下",{"2":{"70":1}}],["commit这个脚本",{"2":{"70":1}}],["commit命令时会先执行pre",{"2":{"70":1}}],["commit的shell脚本",{"2":{"70":1}}],["commitlint",{"2":{"67":1,"71":4}}],["commit",{"2":{"67":2,"70":1,"71":3}}],["com",{"2":{"3":1,"4":2,"11":2}}],["cn",{"2":{"4":1,"11":1}}],["cd配置文件及",{"2":{"4":1}}],["cd的工具",{"2":{"4":1}}],["cd是在阿里云主机上运行的费用还是有点小贵",{"2":{"3":1}}],["cd替换成了github",{"2":{"3":1}}],["cd",{"2":{"2":1,"4":1}}],["ci",{"2":{"2":1,"3":2}}],["这是一个很好的设计模式",{"2":{"79":1}}],["这是一种更细粒度上划分",{"2":{"38":1}}],["这里我先给出我对闭包函数的定义",{"2":{"81":1}}],["这里我们填写production表示生产环境",{"2":{"10":1}}],["这里存在两条原型链",{"2":{"66":1}}],["这种方法的核心是空对象自身是没有属性的",{"2":{"53":1}}],["这种妥协大大降低了tcp的利用率",{"2":{"37":1}}],["这8中类型分为基本类型和引用类型两大部分",{"2":{"45":1}}],["这意味着每次发送的报文都需接收者在接收之后向发送者发送确认消息",{"2":{"40":1}}],["这样便会导致这些变量一直停留在内存中不被销毁",{"2":{"84":1}}],["这样便完成了一次博客的发布工作",{"2":{"4":1}}],["这样就延长了函数中变量的生命周期",{"2":{"83":1}}],["这样就相当于所有的请求都被阻塞住了",{"2":{"40":1}}],["这样我们可以在父作用域中通过访问函数来获取或者修改函数作用域中的定义的变量",{"2":{"82":1}}],["这样既减少发布者",{"2":{"80":1}}],["这样husky可以使用husky",{"2":{"69":1}}],["这样做的好处就是无论用户设置什么类型的git",{"2":{"68":1}}],["这样在git",{"2":{"68":1}}],["这样的命令进行添加",{"2":{"71":1}}],["这样的纯对象",{"2":{"50":1}}],["这样的对象能通过判断",{"2":{"50":1}}],["这样看来一旦客户端发现发送的tcp报文由于某种原因没有收到确认消息",{"2":{"40":1}}],["这样以来即使某一个请求无法收到响应也不会影响到客户端的其他请求正常发送和接收响应",{"2":{"38":1}}],["这样同一域名下的所用http请求被分配到了6个不同的队列中去",{"2":{"35":1}}],["这样当客户端如果再对该域名下的其他资源发起请求时如果tcp连接还没被关闭就会复用该tcp连接从而避免了tcp连接的创建过程减少客户端的等待时间",{"2":{"35":1}}],["这样当客户端对一个域名发起http请求并收到响应后并不会立刻关闭tcp连接",{"2":{"35":1}}],["这段代码主要为mypromise实例增加了两个实例属性value和reason",{"2":{"18":1}}],["这个脚本应该也能使用类似于npx",{"2":{"71":1}}],["这个是类对象的原型链",{"2":{"66":1}}],["这个是实例对象的原型链",{"2":{"66":1}}],["这个私钥不是服务器证书中公钥对应的私钥",{"2":{"29":1}}],["这个reason也不能再改变",{"2":{"18":1}}],["这个函数在创建promise实例的时候同步执行",{"2":{"17":1}}],["这个网址进行访问",{"2":{"3":1}}],["这套系统成功的在阿里云上运行了一年",{"2":{"2":1}}],["这篇文章就是记录一下我是如何为vue组件库项目添加单元测试功能的",{"2":{"1":1}}],["去年的时候心血来潮使用hexo+阿里oss+gitlab的方式搭建了自己的博客系统",{"2":{"2":1}}]],"serializationVersion":2}';export{t as default};
